// Generated by CoffeeScript 1.10.0
(function() {
  var root,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.gen_lines = function(data, scale_coeff, detail, directions, materials, borders, dashed, filtered, filter_detail, filter_directions, filter_materials, filter_dashed) {
    var add_seg, border_color, border_line, border_material, border_points, calc_material, coeff, filter_border_color, filter_border_line, filter_border_material, filter_borders, filter_last_border, filter_last_border_line, filter_last_border_material, fn, fn1, i_first, i_size, j, j_first, j_size, k, k_first, k_size, last_border, last_border_line, last_border_material, n, o, q, ref, ref1, ref2, ref3, ref4, results;
    if (directions.length < 4) {
      directions = [true, true, true, true];
    }
    if (filter_directions.length < 4) {
      filter_directions = [true, true, true, true];
    }
    coeff = 0;
    border_color = "#000000";
    border_material = [
      new THREE.LineBasicMaterial({
        color: border_color,
        linewidth: 1
      }), coeff + 3
    ];
    filter_borders = [[filter_detail[0][0], filter_detail[0][filter_detail[0].length - 1]], [filter_detail[1][0], filter_detail[1][filter_detail[1].length - 1]], [filter_detail[2][0], filter_detail[2][filter_detail[2].length - 1]]];
    coeff = 5;
    filter_border_color = "#0000ff";
    filter_border_material = [
      new THREE.LineBasicMaterial({
        color: filter_border_color,
        linewidth: 1
      }), coeff + 3
    ];
    if (borders.length > 5) {
      filter_last_border_line = function(dir, k, j, i) {
        var r;
        if (dir === 0) {
          r = indexOf.call(borders[3], k) >= 0 && indexOf.call(borders[4], j) >= 0 ? true : false;
        } else if (dir === 1) {
          r = indexOf.call(borders[3], k) >= 0 && indexOf.call(borders[5], i) >= 0 ? true : false;
        } else if (dir === 2) {
          r = indexOf.call(borders[4], j) >= 0 && indexOf.call(borders[5], i) >= 0 ? true : false;
        }
        return r;
      };
    } else {
      filter_last_border_line = function(dir, k, j, i) {
        return false;
      };
    }
    filter_border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(filter_borders[0], k) >= 0 || indexOf.call(filter_borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(filter_borders[0], k) >= 0 || indexOf.call(filter_borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(filter_borders[1], j) >= 0 || indexOf.call(filter_borders[2], i) >= 0 ? true : false;
      }
      return r;
    };
    last_border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(borders[1], j) >= 0 && indexOf.call(borders[2], i) >= 0 ? true : false;
      }
      if (filter_last_border_line(dir, k, j, i)) {
        if (dir === 2) {
          if (borders[0][0] === filter_borders[0][0] && borders[0][1] === filter_borders[0][1]) {
            r = false;
          }
        } else if (dir === 1) {
          if (borders[1][0] === filter_borders[1][0] && borders[1][1] === filter_borders[1][1]) {
            r = false;
          }
        } else if (dir === 0) {
          if (borders[2][0] === filter_borders[2][0] && borders[2][1] === filter_borders[2][1]) {
            r = false;
          }
        }
      }
      return r;
    };
    border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(borders[1], j) >= 0 || indexOf.call(borders[2], i) >= 0 ? true : false;
      }
      return r;
    };
    ref = [0, 0, 0], k_first = ref[0], j_first = ref[1], i_first = ref[2];
    ref1 = [k_last, j_last, i_last], k_size = ref1[0], j_size = ref1[1], i_size = ref1[2];
    calc_material = function(dir, k, j, i, filter) {
      var color, i_coeff, j_coeff, k_coeff, m, mid;
      if (filter == null) {
        filter = false;
      }
      if (filter === true) {
        coeff = 5;
        if (filter_materials.length < 4) {
          if (filter_border_line(dir, k, j, i)) {
            m = filter_border_material;
          } else {
            mid = 0x55;
            i_coeff = dir === 0 ? mid : (i - i_first) / i_size * 0xff;
            j_coeff = dir === 1 ? mid : (j - j_first) / j_size * 0xff;
            k_coeff = dir === 2 ? mid : (k - k_first) / k_size * 0xff;
            color = (i_coeff << 16) + (k_coeff << 8) + j_coeff;
            m = [
              new THREE.LineBasicMaterial({
                color: color,
                linewidth: 1
              }), dir + coeff
            ];
          }
        } else {
          if (filter_border_line(dir, k, j, i)) {
            m = [filter_materials[3], coeff + 3];
          } else {
            m = filter_directions[3] ? [filter_materials[dir], dir + coeff] : [];
          }
        }
      } else {
        coeff = 0;
        if (materials.length < 4) {
          if (border_line(dir, k, j, i)) {
            m = border_material;
          } else {
            mid = 0x45;
            i_coeff = dir === 0 ? mid : (i - i_first) / i_size * 0xff;
            j_coeff = dir === 1 ? mid : (j - j_first) / j_size * 0xff;
            k_coeff = dir === 2 ? mid : (k - k_first) / k_size * 0xff;
            color = (i_coeff << 16) + (j_coeff << 8) + k_coeff;
            m = [
              new THREE.LineBasicMaterial({
                color: color,
                linewidth: 1
              }), dir + coeff
            ];
          }
        } else {
          if (last_border_line(dir, k, j, i)) {
            m = [materials[4], coeff + 4];
          } else if (border_line(dir, k, j, i)) {
            m = [materials[3], coeff + 3];
          } else {
            m = directions[3] ? [materials[dir], dir + coeff] : [];
          }
        }
      }
      return m;
    };
    last_border = 0x000000;
    if (materials.length > 3) {
      last_border = materials[3].color.getHex();
    }
    last_border_material = new THREE.MeshBasicMaterial({
      color: last_border,
      side: THREE.DoubleSide
    });
    filter_last_border = 0x0000ff;
    if (filter_materials.length > 3) {
      filter_last_border = filter_materials[3].color.getHex();
    }
    filter_last_border_material = new THREE.MeshBasicMaterial({
      color: filter_last_border,
      side: THREE.DoubleSide
    });
    border_points = function(dir, a, b, x_seg, pnts, faces) {
      var len, n, results, x, x_ind;
      results = [];
      for (x_ind = n = 0, len = x_seg.length; n < len; x_ind = ++n) {
        x = x_seg[x_ind];
        results.push((function(x) {
          var i, j, k, ref2, ref3, ref4, s;
          if (dir === 0) {
            ref2 = [a, b, x], k = ref2[0], j = ref2[1], i = ref2[2];
          } else if (dir === 1) {
            ref3 = [a, x, b], k = ref3[0], j = ref3[1], i = ref3[2];
          } else if (dir === 2) {
            ref4 = [x, a, b], k = ref4[0], j = ref4[1], i = ref4[2];
          }
          pnts.push(new THREE.Vector3(data[k][j][i][0] * scale_coeff + 0.05, data[k][j][i][1] * scale_coeff, data[k][j][i][2] * scale_coeff));
          pnts.push(new THREE.Vector3(data[k][j][i][0] * scale_coeff, data[k][j][i][1] * scale_coeff + 0.05, data[k][j][i][2] * scale_coeff));
          pnts.push(new THREE.Vector3(data[k][j][i][0] * scale_coeff, data[k][j][i][1] * scale_coeff, data[k][j][i][2] * scale_coeff + 0.05));
          if (x_ind !== 0) {
            s = (x_ind - 1) * 3;
            faces.push(new THREE.Face3(s, s + 1, s + 3));
            faces.push(new THREE.Face3(s + 1, s + 2, s + 4));
            faces.push(new THREE.Face3(s + 2, s, s + 5));
            faces.push(new THREE.Face3(s + 1, s + 4, s + 3));
            faces.push(new THREE.Face3(s + 2, s + 5, s + 4));
            return faces.push(new THREE.Face3(s, s + 3, s + 5));
          }
        })(x));
      }
      return results;
    };
    add_seg = function(p, dir, k, j, i, filter) {
      var m;
      if (filter == null) {
        filter = false;
      }
      if (filter === true) {
        if (filter_directions[dir] && p.length > 1) {
          m = calc_material(dir, k, j, i, true);
          if (m.length > 1) {
            if (filter_border_line(dir, k, j, i)) {
              return add_line(p, scale_coeff, m[0], m[1]);
            } else {
              return add_line(p, scale_coeff, m[0], m[1], filter_dashed);
            }
          }
        }
      } else {
        if (directions[dir] && p.length > 1) {
          m = calc_material(dir, k, j, i);
          if (m.length > 1) {
            if (border_line(dir, k, j, i)) {
              return add_line(p, scale_coeff, m[0], m[1]);
            } else {
              return add_line(p, scale_coeff, m[0], m[1], dashed);
            }
          }
        }
      }
    };
    fn = function(k) {
      var j, o, ref3, results;
      results = [];
      for (j = o = 0, ref3 = j_last; 0 <= ref3 ? o <= ref3 : o >= ref3; j = 0 <= ref3 ? ++o : --o) {
        results.push((function(j) {
          var faces, filter_pnts, flag, fn1, i, pnts, q, ref4, ref5, ref6, results1, results2, t, u;
          if (directions[0] && last_border_line(0, k, j, 0)) {
            pnts = [];
            faces = [];
            border_points(0, k, j, (function() {
              results1 = [];
              for (var q = 0; 0 <= i_last ? q <= i_last : q >= i_last; 0 <= i_last ? q++ : q--){ results1.push(q); }
              return results1;
            }).apply(this), pnts, faces);
            return add_border_line(pnts, scale_coeff, faces, last_border_material, 100500);
          } else {
            if (filter_directions[0] && filter_last_border_line(0, k, j, 0) && borders[5][0] !== borders[5][1]) {
              pnts = [];
              faces = [];
              border_points(0, k, j, (function() {
                results2 = [];
                for (var t = ref4 = borders[5][0], ref5 = borders[5][1]; ref4 <= ref5 ? t <= ref5 : t >= ref5; ref4 <= ref5 ? t++ : t--){ results2.push(t); }
                return results2;
              }).apply(this), pnts, faces);
              add_border_line(pnts, scale_coeff, faces, filter_last_border_material, 100500);
            }
            pnts = [];
            filter_pnts = [];
            flag = -1;
            fn1 = function(i) {
              if (filtered(-1, k, j, i)) {
                if (flag === 1) {
                  pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                  add_seg(pnts, 0, k, j, 0);
                  pnts = [];
                }
                if (indexOf.call(filter_detail[0], k) >= 0 && indexOf.call(filter_detail[1], j) >= 0) {
                  filter_pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                }
                return flag = 0;
              } else {
                if (flag === 0) {
                  add_seg(filter_pnts, 0, k, j, 0, true);
                  filter_pnts = [];
                  pnts.push(data[k][j][i - 1][0], data[k][j][i - 1][1], data[k][j][i - 1][2]);
                }
                if (indexOf.call(detail[0], k) >= 0 && indexOf.call(detail[1], j) >= 0) {
                  pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                }
                return flag = 1;
              }
            };
            for (i = u = 0, ref6 = i_last; 0 <= ref6 ? u <= ref6 : u >= ref6; i = 0 <= ref6 ? ++u : --u) {
              fn1(i);
            }
            add_seg(pnts, 0, k, j, 0);
            return add_seg(filter_pnts, 0, k, j, 0, true);
          }
        })(j));
      }
      return results;
    };
    for (k = n = 0, ref2 = k_last; 0 <= ref2 ? n <= ref2 : n >= ref2; k = 0 <= ref2 ? ++n : --n) {
      fn(k);
    }
    fn1 = function(k) {
      var i, q, ref4, results;
      results = [];
      for (i = q = 0, ref4 = i_last; 0 <= ref4 ? q <= ref4 : q >= ref4; i = 0 <= ref4 ? ++q : --q) {
        results.push((function(i) {
          var faces, filter_pnts, flag, fn2, j, pnts, ref5, ref6, ref7, results1, results2, t, u, v;
          if (directions[1] && last_border_line(1, k, 0, i)) {
            pnts = [];
            faces = [];
            border_points(1, k, i, (function() {
              results1 = [];
              for (var t = 0; 0 <= j_last ? t <= j_last : t >= j_last; 0 <= j_last ? t++ : t--){ results1.push(t); }
              return results1;
            }).apply(this), pnts, faces);
            return add_border_line(pnts, scale_coeff, faces, last_border_material, 100500);
          } else {
            if (filter_directions[1] && filter_last_border_line(1, k, 0, i) && borders[4][0] !== borders[4][1]) {
              pnts = [];
              faces = [];
              border_points(1, k, i, (function() {
                results2 = [];
                for (var u = ref5 = borders[4][0], ref6 = borders[4][1]; ref5 <= ref6 ? u <= ref6 : u >= ref6; ref5 <= ref6 ? u++ : u--){ results2.push(u); }
                return results2;
              }).apply(this), pnts, faces);
              add_border_line(pnts, scale_coeff, faces, filter_last_border_material, 100500);
            }
            pnts = [];
            filter_pnts = [];
            flag = -1;
            fn2 = function(j) {
              if (filtered(-1, k, j, i)) {
                if (flag === 1) {
                  pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                  add_seg(pnts, 1, k, 0, i);
                  pnts = [];
                }
                if (indexOf.call(filter_detail[0], k) >= 0 && indexOf.call(filter_detail[2], i) >= 0) {
                  filter_pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                }
                return flag = 0;
              } else {
                if (flag === 0) {
                  add_seg(filter_pnts, 1, k, 0, i, true);
                  filter_pnts = [];
                  pnts.push(data[k][j - 1][i][0], data[k][j - 1][i][1], data[k][j - 1][i][2]);
                }
                if (indexOf.call(detail[0], k) >= 0 && indexOf.call(detail[2], i) >= 0) {
                  pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                }
                return flag = 1;
              }
            };
            for (j = v = 0, ref7 = j_last; 0 <= ref7 ? v <= ref7 : v >= ref7; j = 0 <= ref7 ? ++v : --v) {
              fn2(j);
            }
            add_seg(pnts, 1, k, 0, i);
            return add_seg(filter_pnts, 1, k, 0, i, true);
          }
        })(i));
      }
      return results;
    };
    for (k = o = 0, ref3 = k_last; 0 <= ref3 ? o <= ref3 : o >= ref3; k = 0 <= ref3 ? ++o : --o) {
      fn1(k);
    }
    results = [];
    for (j = q = 0, ref4 = j_last; 0 <= ref4 ? q <= ref4 : q >= ref4; j = 0 <= ref4 ? ++q : --q) {
      results.push((function(j) {
        var i, ref5, results1, t;
        results1 = [];
        for (i = t = 0, ref5 = i_last; 0 <= ref5 ? t <= ref5 : t >= ref5; i = 0 <= ref5 ? ++t : --t) {
          results1.push((function(i) {
            var faces, filter_pnts, flag, fn2, pnts, ref6, ref7, ref8, results2, results3, u, v, w;
            if (directions[2] && last_border_line(2, 0, j, i)) {
              pnts = [];
              faces = [];
              border_points(2, j, i, (function() {
                results2 = [];
                for (var u = 0; 0 <= k_last ? u <= k_last : u >= k_last; 0 <= k_last ? u++ : u--){ results2.push(u); }
                return results2;
              }).apply(this), pnts, faces);
              return add_border_line(pnts, scale_coeff, faces, last_border_material, 100500);
            } else {
              if (filter_directions[2] && filter_last_border_line(2, 0, j, i) && borders[3][0] !== borders[3][1]) {
                pnts = [];
                faces = [];
                border_points(2, j, i, (function() {
                  results3 = [];
                  for (var v = ref6 = borders[3][0], ref7 = borders[3][1]; ref6 <= ref7 ? v <= ref7 : v >= ref7; ref6 <= ref7 ? v++ : v--){ results3.push(v); }
                  return results3;
                }).apply(this), pnts, faces);
                add_border_line(pnts, scale_coeff, faces, filter_last_border_material, 100500);
              }
              pnts = [];
              filter_pnts = [];
              flag = -1;
              fn2 = function(k) {
                if (filtered(-1, k, j, i)) {
                  if (flag === 1) {
                    pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                    add_seg(pnts, 2, 0, j, i);
                    pnts = [];
                  }
                  if (indexOf.call(filter_detail[1], j) >= 0 && indexOf.call(filter_detail[2], i) >= 0) {
                    filter_pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                  }
                  return flag = 0;
                } else {
                  if (flag === 0) {
                    add_seg(filter_pnts, 2, 0, j, i, true);
                    filter_pnts = [];
                    pnts.push(data[k - 1][j][i][0], data[k - 1][j][i][1], data[k - 1][j][i][2]);
                  }
                  if (indexOf.call(detail[1], j) >= 0 && indexOf.call(detail[2], i) >= 0) {
                    pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
                  }
                  return flag = 1;
                }
              };
              for (k = w = 0, ref8 = k_last; 0 <= ref8 ? w <= ref8 : w >= ref8; k = 0 <= ref8 ? ++w : --w) {
                fn2(k);
              }
              add_seg(pnts, 2, 0, j, i);
              return add_seg(filter_pnts, 2, 0, j, i, true);
            }
          })(i));
        }
        return results1;
      })(j));
    }
    return results;
  };

  root.gen_lines_seg = function(data, scale_coeff, detail, directions, mat, borders, filtered, filter_detail, filter_directions, filter_mat, dashed) {
    var add_seg, border_color, border_line, border_points, calc_color, coeff, convert_color, filter_border_color, filter_border_line, filter_borders, filter_last_border, filter_last_border_line, filter_last_border_material, filter_materials, fn, fn1, fn2, geometry, geometry_pnts, i, i_first, i_size, j, j_first, j_size, k, k_first, k_size, last_border, last_border_line, last_border_material, material, materials, n, o, q, ref, ref1, ref2, ref3, ref4, sceneObject, seg_colors, t, u;
    if (dashed == null) {
      dashed = false;
    }
    if (directions.length < 4) {
      directions = [true, true, true, true];
    }
    if (filter_directions.length < 4) {
      filter_directions = [true, true, true, true];
    }
    coeff = 0;
    border_color = [0, 0, 0];
    filter_borders = [[filter_detail[0][0], filter_detail[0][filter_detail[0].length - 1]], [filter_detail[1][0], filter_detail[1][filter_detail[1].length - 1]], [filter_detail[2][0], filter_detail[2][filter_detail[2].length - 1]]];
    coeff = 5;
    filter_border_color = [0, 0, 1];
    if (borders.length > 5) {
      filter_last_border_line = function(dir, k, j, i) {
        var r;
        if (dir === 0) {
          r = indexOf.call(borders[3], k) >= 0 && indexOf.call(borders[4], j) >= 0 ? true : false;
        } else if (dir === 1) {
          r = indexOf.call(borders[3], k) >= 0 && indexOf.call(borders[5], i) >= 0 ? true : false;
        } else if (dir === 2) {
          r = indexOf.call(borders[4], j) >= 0 && indexOf.call(borders[5], i) >= 0 ? true : false;
        }
        return r;
      };
    } else {
      filter_last_border_line = function(dir, k, j, i) {
        return false;
      };
    }
    filter_border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(filter_borders[0], k) >= 0 || indexOf.call(filter_borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(filter_borders[0], k) >= 0 || indexOf.call(filter_borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(filter_borders[1], j) >= 0 || indexOf.call(filter_borders[2], i) >= 0 ? true : false;
      }
      return r;
    };
    last_border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(borders[0], k) >= 0 && indexOf.call(borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(borders[1], j) >= 0 && indexOf.call(borders[2], i) >= 0 ? true : false;
      }
      if (filter_last_border_line(dir, k, j, i)) {
        if (dir === 2) {
          if (borders[0][0] === filter_borders[0][0] && borders[0][1] === filter_borders[0][1]) {
            r = false;
          }
        } else if (dir === 1) {
          if (borders[1][0] === filter_borders[1][0] && borders[1][1] === filter_borders[1][1]) {
            r = false;
          }
        } else if (dir === 0) {
          if (borders[2][0] === filter_borders[2][0] && borders[2][1] === filter_borders[2][1]) {
            r = false;
          }
        }
      }
      return r;
    };
    border_line = function(dir, k, j, i) {
      var r;
      if (dir === 0) {
        r = indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[1], j) >= 0 ? true : false;
      } else if (dir === 1) {
        r = indexOf.call(borders[0], k) >= 0 || indexOf.call(borders[2], i) >= 0 ? true : false;
      } else if (dir === 2) {
        r = indexOf.call(borders[1], j) >= 0 || indexOf.call(borders[2], i) >= 0 ? true : false;
      }
      return r;
    };
    ref = [0, 0, 0], k_first = ref[0], j_first = ref[1], i_first = ref[2];
    ref1 = [k_last, j_last, i_last], k_size = ref1[0], j_size = ref1[1], i_size = ref1[2];
    convert_color = function(tag) {
      var value;
      value = parseInt(tag.substring(1), 16);
      return [(value >> 16) / 255, ((value & 0x00ff00) >> 8) / 255, (value & 0x0000ff) / 255];
    };
    materials = [];
    filter_materials = [];
    last_border = "#000000";
    if (mat.length > 3) {
      for (i = n = 0; n <= 3; i = ++n) {
        materials.push(convert_color(mat[i]));
      }
      last_border = mat[3];
    }
    filter_last_border = "#0000ff";
    if (filter_mat.length > 3) {
      for (i = o = 0; o <= 3; i = ++o) {
        filter_materials.push(convert_color(filter_mat[i]));
      }
      filter_last_border = filter_mat[3];
    }
    calc_color = function(dir, k, j, i, filter) {
      var color, i_coeff, j_coeff, k_coeff, mid;
      if (filter == null) {
        filter = false;
      }
      if (filter === true) {
        coeff = 5;
        if (filter_materials.length < 4) {
          if (filter_border_line(dir, k, j, i)) {
            color = filter_border_color;
          } else {
            mid = 0x55 / 255;
            i_coeff = dir === 0 ? mid : (i - i_first) / i_size;
            j_coeff = dir === 1 ? mid : (j - j_first) / j_size;
            k_coeff = dir === 2 ? mid : (k - k_first) / k_size;
            color = [i_coeff, k_coeff, j_coeff];
          }
        } else {
          if (filter_border_line(dir, k, j, i)) {
            color = filter_materials[3];
          } else {
            color = filter_directions[3] ? filter_materials[dir] : [];
          }
        }
      } else {
        coeff = 0;
        if (materials.length < 4) {
          if (border_line(dir, k, j, i)) {
            color = border_color;
          } else {
            mid = 0x45 / 255;
            i_coeff = dir === 0 ? mid : (i - i_first) / i_size;
            j_coeff = dir === 1 ? mid : (j - j_first) / j_size;
            k_coeff = dir === 2 ? mid : (k - k_first) / k_size;
            color = [i_coeff, j_coeff, k_coeff];
          }
        } else {
          if (last_border_line(dir, k, j, i)) {
            color = border_color;
          } else if (border_line(dir, k, j, i)) {
            color = materials[3];
          } else {
            color = directions[3] ? materials[dir] : [];
          }
        }
      }
      return color;
    };
    last_border_material = new THREE.MeshBasicMaterial({
      color: parseInt(last_border.substring(1), 16),
      side: THREE.DoubleSide
    });
    filter_last_border_material = new THREE.MeshBasicMaterial({
      color: parseInt(filter_last_border.substring(1), 16),
      side: THREE.DoubleSide
    });
    border_points = function(dir, a, b, x_seg, pnts, faces) {
      var len, q, results, x, x_ind;
      results = [];
      for (x_ind = q = 0, len = x_seg.length; q < len; x_ind = ++q) {
        x = x_seg[x_ind];
        results.push((function(x) {
          var j, k, ref2, ref3, ref4, s;
          if (dir === 0) {
            ref2 = [a, b, x], k = ref2[0], j = ref2[1], i = ref2[2];
          } else if (dir === 1) {
            ref3 = [a, x, b], k = ref3[0], j = ref3[1], i = ref3[2];
          } else if (dir === 2) {
            ref4 = [x, a, b], k = ref4[0], j = ref4[1], i = ref4[2];
          }
          pnts.push(new THREE.Vector3(data[k][j][i][0] * scale_coeff + 0.05, data[k][j][i][1] * scale_coeff, data[k][j][i][2] * scale_coeff));
          pnts.push(new THREE.Vector3(data[k][j][i][0] * scale_coeff, data[k][j][i][1] * scale_coeff + 0.05, data[k][j][i][2] * scale_coeff));
          pnts.push(new THREE.Vector3(data[k][j][i][0] * scale_coeff, data[k][j][i][1] * scale_coeff, data[k][j][i][2] * scale_coeff + 0.05));
          if (x_ind !== 0) {
            s = (x_ind - 1) * 3;
            faces.push(new THREE.Face3(s, s + 1, s + 3));
            faces.push(new THREE.Face3(s + 1, s + 2, s + 4));
            faces.push(new THREE.Face3(s + 2, s, s + 5));
            faces.push(new THREE.Face3(s + 1, s + 4, s + 3));
            faces.push(new THREE.Face3(s + 2, s + 5, s + 4));
            return faces.push(new THREE.Face3(s, s + 3, s + 5));
          }
        })(x));
      }
      return results;
    };
    geometry_pnts = [];
    seg_colors = [];
    add_seg = function(dir, k, j, i, geometry, seg_colors, detail, directions, color) {
      if (((dir === 0 && indexOf.call(detail[0], k) >= 0 && indexOf.call(detail[1], j) >= 0) || (dir === 1 && indexOf.call(detail[0], k) >= 0 && indexOf.call(detail[2], i) >= 0) || (dir === 2 && indexOf.call(detail[1], j) >= 0 && indexOf.call(detail[2], i) >= 0)) && (directions[3] || border_line(dir, k, j, i))) {
        if (directions[dir]) {
          geometry_pnts.push(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
          return seg_colors.push(color[0], color[1], color[2]);
        }
      }
    };
    fn = function(k) {
      var j, ref3, results, t;
      results = [];
      for (j = t = 0, ref3 = j_last; 0 <= ref3 ? t <= ref3 : t >= ref3; j = 0 <= ref3 ? ++t : --t) {
        results.push((function(j) {
          var color, faces, filter_color, flag, pnts, ref4, ref5, ref6, results1, results2, results3, u, v, w;
          color = calc_color(0, k, j, 0);
          filter_color = calc_color(0, k, j, 0, true);
          if (directions[0] && last_border_line(0, k, j, 0)) {
            pnts = [];
            faces = [];
            border_points(0, k, j, (function() {
              results1 = [];
              for (var u = 0; 0 <= i_last ? u <= i_last : u >= i_last; 0 <= i_last ? u++ : u--){ results1.push(u); }
              return results1;
            }).apply(this), pnts, faces);
            return add_border_line_seg(pnts, scale_coeff, faces, last_border_material, 100500);
          } else {
            if (filter_directions[0] && filter_last_border_line(0, k, j, 0) && borders[5][0] !== borders[5][1]) {
              pnts = [];
              faces = [];
              border_points(0, k, j, (function() {
                results2 = [];
                for (var v = ref4 = borders[5][0], ref5 = borders[5][1]; ref4 <= ref5 ? v <= ref5 : v >= ref5; ref4 <= ref5 ? v++ : v--){ results2.push(v); }
                return results2;
              }).apply(this), pnts, faces);
              add_border_line_seg(pnts, scale_coeff, faces, filter_last_border_material, 100500);
            }
            flag = -1;
            results3 = [];
            for (i = w = 0, ref6 = i_last - 1; 0 <= ref6 ? w <= ref6 : w >= ref6; i = 0 <= ref6 ? ++w : --w) {
              results3.push((function(i) {
                if (filtered(0, k, j, i)) {
                  add_seg(0, k, j, i, geometry, seg_colors, filter_detail, filter_directions, filter_color);
                  return add_seg(0, k, j, i + 1, geometry, seg_colors, filter_detail, filter_directions, filter_color);
                } else {
                  add_seg(0, k, j, i, geometry, seg_colors, detail, directions, color);
                  return add_seg(0, k, j, i + 1, geometry, seg_colors, detail, directions, color);
                }
              })(i));
            }
            return results3;
          }
        })(j));
      }
      return results;
    };
    for (k = q = 0, ref2 = k_last; 0 <= ref2 ? q <= ref2 : q >= ref2; k = 0 <= ref2 ? ++q : --q) {
      fn(k);
    }
    fn1 = function(k) {
      var ref4, results, u;
      results = [];
      for (i = u = 0, ref4 = i_last; 0 <= ref4 ? u <= ref4 : u >= ref4; i = 0 <= ref4 ? ++u : --u) {
        results.push((function(i) {
          var color, faces, filter_color, flag, j, pnts, ref5, ref6, ref7, results1, results2, results3, v, w, y;
          color = calc_color(1, k, 0, i);
          filter_color = calc_color(1, k, 0, i, true);
          if (directions[1] && last_border_line(1, k, 0, i)) {
            pnts = [];
            faces = [];
            border_points(1, k, i, (function() {
              results1 = [];
              for (var v = 0; 0 <= j_last ? v <= j_last : v >= j_last; 0 <= j_last ? v++ : v--){ results1.push(v); }
              return results1;
            }).apply(this), pnts, faces);
            return add_border_line_seg(pnts, scale_coeff, faces, last_border_material, 100500);
          } else {
            if (filter_directions[1] && filter_last_border_line(1, k, 0, i) && borders[4][0] !== borders[4][1]) {
              pnts = [];
              faces = [];
              border_points(1, k, i, (function() {
                results2 = [];
                for (var w = ref5 = borders[4][0], ref6 = borders[4][1]; ref5 <= ref6 ? w <= ref6 : w >= ref6; ref5 <= ref6 ? w++ : w--){ results2.push(w); }
                return results2;
              }).apply(this), pnts, faces);
              add_border_line_seg(pnts, scale_coeff, faces, filter_last_border_material, 100500);
            }
            flag = -1;
            results3 = [];
            for (j = y = 0, ref7 = j_last - 1; 0 <= ref7 ? y <= ref7 : y >= ref7; j = 0 <= ref7 ? ++y : --y) {
              results3.push((function(j) {
                if (filtered(1, k, j, i)) {
                  add_seg(1, k, j, i, geometry, seg_colors, filter_detail, filter_directions, filter_color);
                  return add_seg(1, k, j + 1, i, geometry, seg_colors, filter_detail, filter_directions, filter_color);
                } else {
                  add_seg(1, k, j, i, geometry, seg_colors, detail, directions, color);
                  return add_seg(1, k, j + 1, i, geometry, seg_colors, detail, directions, color);
                }
              })(j));
            }
            return results3;
          }
        })(i));
      }
      return results;
    };
    for (k = t = 0, ref3 = k_last; 0 <= ref3 ? t <= ref3 : t >= ref3; k = 0 <= ref3 ? ++t : --t) {
      fn1(k);
    }
    fn2 = function(j) {
      var ref5, results, v;
      results = [];
      for (i = v = 0, ref5 = i_last; 0 <= ref5 ? v <= ref5 : v >= ref5; i = 0 <= ref5 ? ++v : --v) {
        results.push((function(i) {
          var color, faces, filter_color, flag, pnts, ref6, ref7, ref8, results1, results2, results3, w, y, z;
          color = calc_color(2, 0, j, i);
          filter_color = calc_color(2, 0, j, i, true);
          if (directions[2] && last_border_line(2, 0, j, i)) {
            pnts = [];
            faces = [];
            border_points(2, j, i, (function() {
              results1 = [];
              for (var w = 0; 0 <= k_last ? w <= k_last : w >= k_last; 0 <= k_last ? w++ : w--){ results1.push(w); }
              return results1;
            }).apply(this), pnts, faces);
            return add_border_line_seg(pnts, scale_coeff, faces, last_border_material, 100500);
          } else {
            if (filter_directions[2] && filter_last_border_line(2, 0, j, i) && borders[3][0] !== borders[3][1]) {
              pnts = [];
              faces = [];
              border_points(2, j, i, (function() {
                results2 = [];
                for (var y = ref6 = borders[3][0], ref7 = borders[3][1]; ref6 <= ref7 ? y <= ref7 : y >= ref7; ref6 <= ref7 ? y++ : y--){ results2.push(y); }
                return results2;
              }).apply(this), pnts, faces);
              add_border_line_seg(pnts, scale_coeff, faces, filter_last_border_material, 100500);
            }
            flag = -1;
            results3 = [];
            for (k = z = 0, ref8 = k_last - 1; 0 <= ref8 ? z <= ref8 : z >= ref8; k = 0 <= ref8 ? ++z : --z) {
              results3.push((function(k) {
                if (filtered(2, k, j, i)) {
                  add_seg(2, k, j, i, geometry, seg_colors, filter_detail, filter_directions, filter_color);
                  return add_seg(2, k + 1, j, i, geometry, seg_colors, filter_detail, filter_directions, filter_color);
                } else {
                  add_seg(2, k, j, i, geometry, seg_colors, detail, directions, color);
                  return add_seg(2, k + 1, j, i, geometry, seg_colors, detail, directions, color);
                }
              })(k));
            }
            return results3;
          }
        })(i));
      }
      return results;
    };
    for (j = u = 0, ref4 = j_last; 0 <= ref4 ? u <= ref4 : u >= ref4; j = 0 <= ref4 ? ++u : --u) {
      fn2(j);
    }
    if (geometry_pnts.length) {
      geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry_pnts), 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(seg_colors), 3));
      geometry.computeBoundingSphere();
      
      if (!dashed) {
        material = new THREE.LineBasicMaterial({
          linewidth: 1,
          vertexColors: THREE.VertexColors
        });
      } else {
        material = new THREE.LineDashedMaterial({
          linewidth: 1,
          vertexColors: THREE.VertexColors,
          dashSize: 0.02,
          gapSize: 0.01
        });
      }
      sceneObject = new THREE.LineSegments(geometry, material);
      sceneObject.scale.x = scale_coeff;
      sceneObject.scale.y = scale_coeff;
      sceneObject.scale.z = scale_coeff;
      sceneObject.computeLineDistances();
      return root.lines_seg.add(sceneObject);
    }
  };

  root.gen_surfaces = function(data, scale_coeff, det, dir, mat, filter, filter_directions, filter_materials, filter_scalar, filter_list) {
    var compare, detail, directions, filter_cells, filter_internal, fn, fn1, fn2, fn3, get_segment, i, i_first, i_last, i_lst_back, i_lst_filter, i_lst_front, i_lst_main, i_part, i_size, ind, internal_area, j_first, j_last, j_lst_back, j_lst_filter, j_lst_front, j_lst_main, j_part, j_size, k, k_first, k_index, k_last, k_lst_back, k_lst_filter, k_lst_front, k_lst_main, k_part, k_size, len, len1, mask, materials, merge, n, o, q, ref, results, t, u, vec, x, xk;
    if (filter == null) {
      filter = [];
    }
    if (filter_directions == null) {
      filter_directions = [];
    }
    if (filter_materials == null) {
      filter_materials = [];
    }
    if (filter_scalar == null) {
      filter_scalar = [];
    }
    if (filter_list == null) {
      filter_list = [];
    }
    if (filter.length < 3 && filter_directions.length < 3) {
      filter_directions = [false, false, false, true];
    }
    k_first = 0;
    j_first = 0;
    i_first = 0;
    if (filter.length < 3 && !filter_scalar.length && !filter_list.length && (!dir[0] && !dir[1] && dir[2])) {
      vec = function(k, j, i) {
        return new THREE.Vector3(data[j][i][k][0], data[j][i][k][1], data[j][i][k][2]);
      };
      detail = [det[2], det[0], det[1]];
      directions = [dir[2], dir[0], dir[1], dir[3]];
      materials = [mat[2], mat[0], mat[1]];
      k_last = data[0][0].length - 1;
      j_last = data.length - 1;
      i_last = data[0].length - 1;
    } else if (filter.length < 3 && !filter_scalar.length && !filter_list.length && ((!dir[0] && dir[1] && !dir[2]) || (!dir[0] && dir[1] && dir[2]))) {
      vec = function(k, j, i) {
        return new THREE.Vector3(data[i][k][j][0], data[i][k][j][1], data[i][k][j][2]);
      };
      detail = [det[1], det[2], det[0]];
      directions = [dir[1], dir[2], dir[0], dir[3]];
      materials = [mat[1], mat[2], mat[0]];
      k_last = data[0].length - 1;
      j_last = data[0][0].length - 1;
      i_last = data.length - 1;
    } else {
      vec = function(k, j, i) {
        return new THREE.Vector3(data[k][j][i][0], data[k][j][i][1], data[k][j][i][2]);
      };
      detail = [det[0], det[1], det[2]];
      directions = [dir[0], dir[1], dir[2], dir[3]];
      materials = [mat[0], mat[1], mat[2]];
      k_last = data.length - 1;
      j_last = data[0].length - 1;
      i_last = data[0][0].length - 1;
    }
    get_segment = function(l, r, step) {
      var fn, lst, n, ref, ref1, ref2, x;
      lst = [];
      fn = function(x) {
        return lst.push(x);
      };
      for (x = n = ref = l, ref1 = r, ref2 = step; ref2 > 0 ? n <= ref1 : n >= ref1; x = n += ref2) {
        fn(x);
      }
      if (lst[lst.length - 1] !== r) {
        lst.push(r);
      }
      return lst;
    };
    if (filter.length > 2) {
      fn = function(i) {
        var f;
        if (filter[i][0] < 0) {
          filter[i][0] = 0;
        }
        if (filter[i][1] < 0) {
          filter[i][1] = 0;
        }
        if (filter[i][2] < 1) {
          filter[i][2] = 1;
        }
        if (filter[i][0] > filter[i][1]) {
          f = filter[i][0];
          filter[i][0] = filter[i][1];
          return filter[i][1] = f;
        }
      };
      for (i = n = 0; n <= 2; i = ++n) {
        fn(i);
      }
      fn1 = function(i) {
        if (filter[0][i] > k_last) {
          filter[0][i] = k_last;
        }
        if (filter[1][i] > j_last) {
          filter[1][i] = j_last;
        }
        if (filter[2][i] > i_last) {
          return filter[2][i] = i_last;
        }
      };
      for (i = o = 0; o <= 2; i = ++o) {
        fn1(i);
      }
    }
    if (filter.length > 2 && filter_materials.length > 2) {
      k_lst_main = get_segment(k_first, k_last, detail[0]);
      j_lst_main = get_segment(j_first, j_last, detail[1]);
      i_lst_main = get_segment(i_first, i_last, detail[2]);
      k_lst_filter = get_segment(filter[0][0], filter[0][1], filter[0][2]);
      j_lst_filter = get_segment(filter[1][0], filter[1][1], filter[1][2]);
      i_lst_filter = get_segment(filter[2][0], filter[2][1], filter[2][2]);
      merge = function(a, b) {
        return a.concat(b.filter(function(x) {
          return a.indexOf(x) < 0;
        }));
      };
      k_lst_front = merge(k_lst_main, k_lst_filter);
      j_lst_front = merge(j_lst_main, j_lst_filter);
      i_lst_front = merge(i_lst_main, i_lst_filter);
      compare = function(a, b) {
        return a - b;
      };
      k_lst_front.sort(compare);
      j_lst_front.sort(compare);
      i_lst_front.sort(compare);
      k_lst_back = k_lst_front.slice();
      j_lst_back = j_lst_front.slice();
      i_lst_back = i_lst_front.slice();
      k_lst_back.reverse();
      j_lst_back.reverse();
      i_lst_back.reverse();
      filter_internal = true;
    } else {
      if (filter.length > 2) {
        k_first = filter[0][0];
        j_first = filter[1][0];
        i_first = filter[2][0];
        k_last = filter[0][1];
        j_last = filter[1][1];
        i_last = filter[2][1];
        detail = [filter[0][2], filter[1][2], filter[2][2]];
      }
      k_lst_front = get_segment(k_first, k_last, detail[0]);
      j_lst_front = get_segment(j_first, j_last, detail[1]);
      i_lst_front = get_segment(i_first, i_last, detail[2]);
      k_lst_back = get_segment(k_first, k_last, detail[0]);
      j_lst_back = get_segment(j_first, j_last, detail[1]);
      i_lst_back = get_segment(i_first, i_last, detail[2]);
      k_lst_back.reverse();
      j_lst_back.reverse();
      i_lst_back.reverse();
    }
    k_size = k_last - k_first;
    j_size = j_last - j_first;
    i_size = i_last - i_first;
    if (k_size < 1) {
      k_size = 1;
    }
    if (j_size < 1) {
      j_size = 1;
    }
    if (i_size < 1) {
      i_size = 1;
    }
    internal_area = function(dir, k, j, i) {
      var f1, f2, f3;
      f1 = f2 = f3 = true;
      if (dir !== 0) {
        f1 = k >= filter[0][0] && k < filter[0][1] ? true : false;
      }
      if (dir !== 1) {
        f2 = j >= filter[1][0] && j < filter[1][1] ? true : false;
      }
      if (dir !== 2) {
        f3 = i >= filter[2][0] && i < filter[2][1] ? true : false;
      }
      return f1 && f2 && f3;
    };
    if (filter_scalar.length) {
      root.scalar = filter_scalar[0] + 2;
      internal_area = function(dir, k, j, i) {
        var ci_lst, cj_lst, ck, ck_lst, fn2, len, q, res;
        res = false;
        if (k > data.length - 1 || j > data[0].length - 1 || i > data[0][0].length - 1) {
          return res;
        }
        ck_lst = dir === 0 && k > 0 ? [-1, 0] : [0];
        cj_lst = dir === 1 && j > 0 ? [-1, 0] : [0];
        ci_lst = dir === 2 && i > 0 ? [-1, 0] : [0];
        if (k + 1 === data.length - 1) {
          ck_lst.push(1);
        }
        if (j + 1 === data[0].length - 1) {
          cj_lst.push(1);
        }
        if (i + 1 === data[0][0].length - 1) {
          ci_lst.push(1);
        }
        if (!res) {
          fn2 = function(ck) {
            var cj, len1, results, t;
            if (!res) {
              results = [];
              for (t = 0, len1 = cj_lst.length; t < len1; t++) {
                cj = cj_lst[t];
                results.push((function(cj) {
                  var ci, len2, results1, u;
                  if (!res) {
                    results1 = [];
                    for (u = 0, len2 = ci_lst.length; u < len2; u++) {
                      ci = ci_lst[u];
                      results1.push((function(ci) {
                        var value;
                        value = data[k + ck][j + cj][i + ci][scalar];
                        if (value >= filter_scalar[1][0] && value <= filter_scalar[1][1]) {
                          return res = true;
                        }
                      })(ci));
                    }
                    return results1;
                  }
                })(cj));
              }
              return results;
            }
          };
          for (q = 0, len = ck_lst.length; q < len; q++) {
            ck = ck_lst[q];
            fn2(ck);
          }
        }
        return res;
      };
      k_lst_main = get_segment(k_first, k_last, detail[0]);
      j_lst_main = get_segment(j_first, j_last, detail[1]);
      i_lst_main = get_segment(i_first, i_last, detail[2]);
      k_lst_front = get_segment(k_first, k_last, 1);
      j_lst_front = get_segment(j_first, j_last, 1);
      i_lst_front = get_segment(i_first, i_last, 1);
      k_lst_back = get_segment(k_first, k_last, 1);
      j_lst_back = get_segment(j_first, j_last, 1);
      i_lst_back = get_segment(i_first, i_last, 1);
    } else if (filter_list.length) {
      mask = (function() {
        var q, ref, results;
        results = [];
        for (x = q = 0, ref = data.length; 0 <= ref ? q < ref : q > ref; x = 0 <= ref ? ++q : --q) {
          results.push([]);
        }
        return results;
      })();
      fn2 = function(xk) {
        var ref1, results, t, xj;
        mask[xk] = (function() {
          var ref1, results, t;
          results = [];
          for (x = t = 0, ref1 = data[0].length; 0 <= ref1 ? t < ref1 : t > ref1; x = 0 <= ref1 ? ++t : --t) {
            results.push([]);
          }
          return results;
        })();
        results = [];
        for (xj = t = 0, ref1 = data[0].length; 0 <= ref1 ? t < ref1 : t > ref1; xj = 0 <= ref1 ? ++t : --t) {
          results.push((function(xj) {
            return mask[xk][xj] = (function() {
              var ref2, results1, u;
              results1 = [];
              for (u = 0, ref2 = data[0][0].length; 0 <= ref2 ? u < ref2 : u > ref2; 0 <= ref2 ? u++ : u--) {
                results1.push(false);
              }
              return results1;
            })();
          })(xj));
        }
        return results;
      };
      for (xk = q = 0, ref = data.length; 0 <= ref ? q < ref : q > ref; xk = 0 <= ref ? ++q : --q) {
        fn2(xk);
      }
      fn3 = function(ind) {
        if (ind.length && mask.length > ind[2] && mask[ind[2]].length > ind[1] && mask[ind[2]][ind[1]].length > ind[0]) {
          return mask[ind[2]][ind[1]][ind[0]] = true;
        }
      };
      for (t = 0, len = filter_list.length; t < len; t++) {
        ind = filter_list[t];
        fn3(ind);
      }
      internal_area = function(dir, k, j, i) {
        var ci_lst, cj_lst, ck, ck_lst, fn4, len1, res, u;
        res = false;
        if (k > data.length - 1 || j > data[0].length - 1 || i > data[0][0].length - 1) {
          return res;
        }
        ck_lst = dir !== 1 && dir !== 2 && k > 0 ? [-1, 0] : [0];
        cj_lst = dir !== 0 && dir !== 2 && j > 0 ? [-1, 0] : [0];
        ci_lst = dir !== 0 && dir !== 1 && i > 0 ? [-1, 0] : [0];
        if (k + 1 === data.length - 1) {
          ck_lst.push(1);
        }
        if (j + 1 === data[0].length - 1) {
          cj_lst.push(1);
        }
        if (i + 1 === data[0][0].length - 1) {
          ci_lst.push(1);
        }
        if (!res) {
          fn4 = function(ck) {
            var cj, len2, results, v;
            if (!res) {
              results = [];
              for (v = 0, len2 = cj_lst.length; v < len2; v++) {
                cj = cj_lst[v];
                results.push((function(cj) {
                  var ci, len3, results1, w;
                  if (!res) {
                    results1 = [];
                    for (w = 0, len3 = ci_lst.length; w < len3; w++) {
                      ci = ci_lst[w];
                      results1.push((function(ci) {
                        if (mask[k + ck][j + cj][i + ci]) {
                          return res = true;
                        }
                      })(ci));
                    }
                    return results1;
                  }
                })(cj));
              }
              return results;
            }
          };
          for (u = 0, len1 = ck_lst.length; u < len1; u++) {
            ck = ck_lst[u];
            fn4(ck);
          }
        }
        return res;
      };
      k_lst_main = get_segment(k_first, k_last, detail[0]);
      j_lst_main = get_segment(j_first, j_last, detail[1]);
      i_lst_main = get_segment(i_first, i_last, detail[2]);
      k_lst_front = get_segment(k_first, k_last, 1);
      j_lst_front = get_segment(j_first, j_last, 1);
      i_lst_front = get_segment(i_first, i_last, 1);
      k_lst_back = get_segment(k_first, k_last, 1);
      j_lst_back = get_segment(j_first, j_last, 1);
      i_lst_back = get_segment(i_first, i_last, 1);
    }
    filter_cells = filter_list.length || filter_scalar.length ? true : false;
    i_part = function(dir, i_index, k1, k2, j1, j2) {
      var faces, faces_internal, fn4, fn5, get_face_0, get_face_1, j_index_size, k, k_index_size, ref1, ref2, ref3, u, v, vertices;
      if (dir === 0) {
        get_face_0 = function(a, b) {
          return new THREE.Face3(b, a + 1, a);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b + 1, a + 1, b);
        };
        i = i_lst_back[i_index];
      } else {
        get_face_0 = function(a, b) {
          return new THREE.Face3(a, a + 1, b);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b, a + 1, b + 1);
        };
        i = i_lst_front[i_index];
      }
      k_index_size = k2 - k1;
      j_index_size = j2 - j1;
      if (k1 !== k2 && j1 !== j2) {
        vertices = [];
        fn4 = function(k) {
          var j, ref3, ref4, results, v;
          results = [];
          for (j = v = ref3 = j1, ref4 = j2; ref3 <= ref4 ? v <= ref4 : v >= ref4; j = ref3 <= ref4 ? ++v : --v) {
            results.push((function(j) {
              return vertices.push(vec(k, j, i));
            })(j));
          }
          return results;
        };
        for (k = u = ref1 = k1, ref2 = k2; ref1 <= ref2 ? u <= ref2 : u >= ref2; k = ref1 <= ref2 ? ++u : --u) {
          fn4(k);
        }
        faces = [];
        faces_internal = [];
        fn5 = function(k) {
          var j, ref4, results, w;
          results = [];
          for (j = w = 0, ref4 = j_index_size - 1; 0 <= ref4 ? w <= ref4 : w >= ref4; j = 0 <= ref4 ? ++w : --w) {
            results.push((function(j) {
              var a, b, face_0, face_1, j0, k0;
              a = (j_index_size + 1) * k + j;
              b = (j_index_size + 1) * (k + 1) + j;
              face_0 = get_face_0(a, b);
              face_1 = get_face_1(a, b);
              if ((filter_internal && i >= filter[2][0] && i <= filter[2][1]) || filter_cells) {
                k0 = k + k1;
                j0 = j + j1;
                if (internal_area(2, k0, j0, i)) {
                  if (filter_cells || (indexOf.call(i_lst_filter, i) >= 0)) {
                    return faces_internal.push(face_0, face_1);
                  }
                } else if ((indexOf.call(i_lst_main, i) >= 0)) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(j));
          }
          return results;
        };
        for (k = v = 0, ref3 = k_index_size - 1; 0 <= ref3 ? v <= ref3 : v >= ref3; k = 0 <= ref3 ? ++v : --v) {
          fn5(k);
        }
        if (faces.length > 0 && directions[2] && (directions[3] || i_index === 0 || i_index === i_lst_front.length - 1)) {
          add_surface(vertices, scale_coeff, faces, materials[2], 2);
        }
        if ((filter_internal || filter_cells) && faces_internal.length > 0 && filter_directions[2] && (filter_directions[3] || i === i_lst_filter[0] || i === i_lst_filter[i_lst_filter.length - 1])) {
          return add_surface(vertices, scale_coeff, faces_internal, filter_materials[2], 5);
        }
      }
    };
    j_part = function(dir, j_index, k1, k2) {
      var aa, ab, ac, ad, ae, faces, faces_internal, fn10, fn11, fn4, fn5, fn6, fn7, fn8, fn9, get_face_0, get_face_1, i_index, j, j1, j2, k, k_index_size, len1, len2, len3, len4, len5, len6, len7, len8, ref1, ref2, ref3, results, results1, u, v, vertices, w, y, z;
      if (dir !== 0) {
        if (j_index > 0) {
          j1 = j_lst_front[j_index - 1];
          j2 = j_lst_front[j_index];
          if (j_index >= j_lst_front.length / 2) {
            fn4 = function(i) {
              if (i_index >= i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = u = 0, len1 = i_lst_front.length; u < len1; i_index = ++u) {
              i = i_lst_front[i_index];
              fn4(i);
            }
            fn5 = function(i) {
              if (i_index > i_lst_front.length / 2) {
                return i_part(0, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = v = 0, len2 = i_lst_back.length; v < len2; i_index = ++v) {
              i = i_lst_back[i_index];
              fn5(i);
            }
          } else {
            fn6 = function(i) {
              if (i_index < i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = w = 0, len3 = i_lst_front.length; w < len3; i_index = ++w) {
              i = i_lst_front[i_index];
              fn6(i);
            }
            fn7 = function(i) {
              if (i_index <= i_lst_front.length / 2) {
                return i_part(0, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = y = 0, len4 = i_lst_back.length; y < len4; i_index = ++y) {
              i = i_lst_back[i_index];
              fn7(i);
            }
          }
        }
      }
      j = j_lst_front[j_index];
      if (dir === 0) {
        get_face_0 = function(a, b) {
          return new THREE.Face3(a, a + 1, b);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b, a + 1, b + 1);
        };
      } else {
        get_face_0 = function(a, b) {
          return new THREE.Face3(b, a + 1, a);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b + 1, a + 1, b);
        };
      }
      k_index_size = k2 - k1;
      if (k1 !== k2 && i_first !== i_last) {
        vertices = [];
        fn8 = function(k) {
          var aa, ref3, ref4, results;
          results = [];
          for (i = aa = ref3 = i_first, ref4 = i_last; ref3 <= ref4 ? aa <= ref4 : aa >= ref4; i = ref3 <= ref4 ? ++aa : --aa) {
            results.push((function(i) {
              return vertices.push(vec(k, j, i));
            })(i));
          }
          return results;
        };
        for (k = z = ref1 = k1, ref2 = k2; ref1 <= ref2 ? z <= ref2 : z >= ref2; k = ref1 <= ref2 ? ++z : --z) {
          fn8(k);
        }
        faces = [];
        faces_internal = [];
        fn9 = function(k) {
          var ab, ref4, results;
          results = [];
          for (i = ab = 0, ref4 = i_size - 1; 0 <= ref4 ? ab <= ref4 : ab >= ref4; i = 0 <= ref4 ? ++ab : --ab) {
            results.push((function(i) {
              var a, b, face_0, face_1, k0;
              a = (i_size + 1) * k + i;
              b = (i_size + 1) * (k + 1) + i;
              face_0 = get_face_0(a, b);
              face_1 = get_face_1(a, b);
              if (filter_internal && j >= filter[1][0] && j <= filter[1][1] || filter_cells) {
                k0 = k + k1;
                if (internal_area(1, k0, j, i)) {
                  if (filter_cells || (indexOf.call(j_lst_filter, j) >= 0)) {
                    return faces_internal.push(face_0, face_1);
                  }
                } else if ((indexOf.call(j_lst_main, j) >= 0)) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(i));
          }
          return results;
        };
        for (k = aa = 0, ref3 = k_index_size - 1; 0 <= ref3 ? aa <= ref3 : aa >= ref3; k = 0 <= ref3 ? ++aa : --aa) {
          fn9(k);
        }
        if (faces.length > 0 && directions[1] && (directions[3] || j_index === 0 || j_index === j_lst_front.length - 1)) {
          add_surface(vertices, scale_coeff, faces, materials[1], 1);
        }
        if ((filter_internal || filter_cells) && faces_internal.length > 0 && filter_directions[1] && (filter_directions[3] || j === j_lst_filter[0] || j === j_lst_filter[j_lst_filter.length - 1])) {
          add_surface(vertices, scale_coeff, faces_internal, filter_materials[1], 4);
        }
      }
      if (dir !== 1) {
        if (j_index > 0) {
          j1 = j_lst_front[j_index - 1];
          j2 = j_lst_front[j_index];
          if (j_index >= j_lst_front.length / 2) {
            fn10 = function(i) {
              if (i_index < i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = ab = 0, len5 = i_lst_front.length; ab < len5; i_index = ++ab) {
              i = i_lst_front[i_index];
              fn10(i);
            }
            results = [];
            for (i_index = ac = 0, len6 = i_lst_back.length; ac < len6; i_index = ++ac) {
              i = i_lst_back[i_index];
              results.push((function(i) {
                if (i_index <= i_lst_front.length / 2) {
                  return i_part(0, i_index, k1, k2, j1, j2);
                }
              })(i));
            }
            return results;
          } else {
            fn11 = function(i) {
              if (i_index >= i_lst_front.length / 2) {
                return i_part(1, i_index, k1, k2, j1, j2);
              }
            };
            for (i_index = ad = 0, len7 = i_lst_front.length; ad < len7; i_index = ++ad) {
              i = i_lst_front[i_index];
              fn11(i);
            }
            results1 = [];
            for (i_index = ae = 0, len8 = i_lst_back.length; ae < len8; i_index = ++ae) {
              i = i_lst_back[i_index];
              results1.push((function(i) {
                if (i_index > i_lst_front.length / 2) {
                  return i_part(0, i_index, k1, k2, j1, j2);
                }
              })(i));
            }
            return results1;
          }
        }
      }
    };
    k_part = function(dir, k_index) {
      var faces, faces_internal, fn4, fn5, fn6, get_face_0, get_face_1, j, j_index, k, k1, k2, len1, len2, ref1, ref2, ref3, results, u, v, vertices, w, y;
      if (dir !== 0 && k_index > 0) {
        k1 = k_lst_front[k_index - 1];
        k2 = k_lst_front[k_index];
        if (k_index >= k_lst_front.length / 2) {
          fn4 = function(j) {
            j_part(0, j_lst_front.length - 1 - j_index, k1, k2);
            return j_part(1, j_index, k1, k2);
          };
          for (j_index = u = 0, len1 = j_lst_front.length; u < len1; j_index = ++u) {
            j = j_lst_front[j_index];
            fn4(j);
          }
        }
      }
      k = k_lst_front[k_index];
      if (dir === 0) {
        get_face_0 = function(a, b) {
          return new THREE.Face3(b, a + 1, a);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b + 1, a + 1, b);
        };
      } else {
        get_face_0 = function(a, b) {
          return new THREE.Face3(a, a + 1, b);
        };
        get_face_1 = function(a, b) {
          return new THREE.Face3(b, a + 1, b + 1);
        };
      }
      if (j_first !== j_last && i_first !== i_last) {
        vertices = [];
        fn5 = function(j) {
          var ref3, ref4, results, w;
          results = [];
          for (i = w = ref3 = i_first, ref4 = i_last; ref3 <= ref4 ? w <= ref4 : w >= ref4; i = ref3 <= ref4 ? ++w : --w) {
            results.push((function(i) {
              return vertices.push(vec(k, j, i));
            })(i));
          }
          return results;
        };
        for (j = v = ref1 = j_first, ref2 = j_last; ref1 <= ref2 ? v <= ref2 : v >= ref2; j = ref1 <= ref2 ? ++v : --v) {
          fn5(j);
        }
        faces = [];
        faces_internal = [];
        fn6 = function(j) {
          var ref4, results, y;
          results = [];
          for (i = y = 0, ref4 = i_size - 1; 0 <= ref4 ? y <= ref4 : y >= ref4; i = 0 <= ref4 ? ++y : --y) {
            results.push((function(i) {
              var a, b, face_0, face_1;
              a = (i_size + 1) * j + i;
              b = (i_size + 1) * (j + 1) + i;
              face_0 = get_face_0(a, b);
              face_1 = get_face_1(a, b);
              if (filter_internal && k >= filter[0][0] && k <= filter[0][1] || filter_cells) {
                if (internal_area(0, k, j, i)) {
                  if (filter_cells || (indexOf.call(k_lst_filter, k) >= 0)) {
                    return faces_internal.push(face_0, face_1);
                  }
                } else if ((indexOf.call(k_lst_main, k) >= 0)) {
                  return faces.push(face_0, face_1);
                }
              } else {
                return faces.push(face_0, face_1);
              }
            })(i));
          }
          return results;
        };
        for (j = w = 0, ref3 = j_size - 1; 0 <= ref3 ? w <= ref3 : w >= ref3; j = 0 <= ref3 ? ++w : --w) {
          fn6(j);
        }
        if (faces.length > 0 && directions[0] && (directions[3] || k_index === 0 || k_index === k_lst_front.length - 1)) {
          add_surface(vertices, scale_coeff, faces, materials[0], 0);
        }
        if ((filter_internal || filter_cells) && faces_internal.length > 0 && filter_directions[0] && (filter_directions[3] || k === k_lst_filter[0] || k === k_lst_filter[k_lst_filter.length - 1])) {
          add_surface(vertices, scale_coeff, faces_internal, filter_materials[0], 3);
        }
      }
      if (dir !== 1 && k_index > 0) {
        k1 = k_lst_front[k_index - 1];
        k2 = k_lst_front[k_index];
        if (k_index < k_lst_front.length / 2) {
          results = [];
          for (j_index = y = 0, len2 = j_lst_front.length; y < len2; j_index = ++y) {
            j = j_lst_front[j_index];
            results.push((function(j) {
              j_part(0, j_lst_front.length - 1 - j_index, k1, k2);
              return j_part(1, j_index, k1, k2);
            })(j));
          }
          return results;
        }
      }
    };
    results = [];
    for (k_index = u = 0, len1 = k_lst_front.length; u < len1; k_index = ++u) {
      k = k_lst_front[k_index];
      results.push((function(k) {
        k_part(1, k_index);
        return k_part(0, k_lst_front.length - 1 - k_index);
      })(k));
    }
    return results;
  };

  root.add_line = function(pnts, scale_coeff, material, name, dashed) {
    var geometry, sceneObject;
    if (dashed == null) {
      dashed = false;
    }
    geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(pnts), 3));
    geometry.computeBoundingSphere();
    
    if (!dashed) {
      sceneObject = new THREE.Line(geometry, material);
    } else {
      sceneObject = new THREE.LineSegments(geometry, material);
    }
    sceneObject.name = name;
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    sceneObject.computeLineDistances();
    return root.lines.add(sceneObject);
  };

  root.add_border_line = function(vertices, scale_coeff, faces, material, name) {
    var geometry, sceneObject;
    geometry = new THREE.Geometry();
    geometry.vertices = vertices;
    geometry.faces = faces;
    geometry.computeBoundingSphere();
    sceneObject = new THREE.Mesh(geometry, material);
    sceneObject.name = name;
    return root.lines.add(sceneObject);
  };

  root.add_border_line_seg = function(vertices, scale_coeff, faces, material, name) {
    var geometry, sceneObject;
    geometry = new THREE.Geometry();
    geometry.vertices = vertices;
    geometry.faces = faces;
    geometry.computeBoundingSphere();
    sceneObject = new THREE.Mesh(geometry, material);
    sceneObject.name = name;
    return root.lines_seg.add(sceneObject);
  };

  root.add_surface = function(vertices, scale_coeff, faces, material, name) {
    var geometry, sceneObject;
    geometry = new THREE.Geometry();
    geometry.vertices = vertices;
    geometry.faces = faces;
    geometry.computeBoundingSphere();
    sceneObject = new THREE.Mesh(geometry);
    sceneObject.name = name;
    sceneObject.scale.x = scale_coeff;
    sceneObject.scale.y = scale_coeff;
    sceneObject.scale.z = scale_coeff;
    sceneObject.updateMatrix();
    root.faces_materials.push(material);
    root.faces_names.push(name);
    return root.faces_geometry.merge(sceneObject.geometry, sceneObject.matrix, root.faces_materials.length - 1);
  };

  root.GridLines = {
    init: function(data, scale_coeff, detail, directions, materials, colors, options, filter, filter_directions, filter_materials, filter_colors, filter_options, filter_scalar, filter_list) {
      var borders, d, filter_d, filtered, fn, fn1, fn2, fn3, get_segment, i, ind, len, mask, n, o, q, ref, t, x, xk;
      root.lines_seg = new THREE.Object3D();
      root.lines = new THREE.Object3D();
      root.k_last = data.length - 1;
      root.j_last = data[0].length - 1;
      root.i_last = data[0][0].length - 1;
      get_segment = function(l, r, step) {
        var fn, lst, n, ref, ref1, ref2, x;
        lst = [];
        fn = function(x) {
          return lst.push(x);
        };
        for (x = n = ref = l, ref1 = r, ref2 = step; ref2 > 0 ? n <= ref1 : n >= ref1; x = n += ref2) {
          fn(x);
        }
        if (lst[lst.length - 1] !== r) {
          lst.push(r);
        }
        return lst;
      };
      d = [get_segment(0, k_last, detail[0]), get_segment(0, j_last, detail[1]), get_segment(0, i_last, detail[2])];
      if (filter.length > 0) {
        fn = function(i) {
          var f;
          if (filter[i][0] < 0) {
            filter[i][0] = 0;
          }
          if (filter[i][1] < 0) {
            filter[i][1] = 0;
          }
          if (filter[i][2] < 1) {
            filter[i][2] = 1;
          }
          if (filter[i][0] > filter[i][1]) {
            f = filter[i][0];
            filter[i][0] = filter[i][1];
            return filter[i][1] = f;
          }
        };
        for (i = n = 0; n <= 2; i = ++n) {
          fn(i);
        }
        fn1 = function(i) {
          if (filter[0][i] > k_last) {
            filter[0][i] = k_last;
          }
          if (filter[1][i] > j_last) {
            filter[1][i] = j_last;
          }
          if (filter[2][i] > i_last) {
            return filter[2][i] = i_last;
          }
        };
        for (i = o = 0; o <= 2; i = ++o) {
          fn1(i);
        }
        root.filter_k_segment = get_segment(filter[0][0], filter[0][1], filter[0][2]);
        root.filter_j_segment = get_segment(filter[1][0], filter[1][1], filter[1][2]);
        root.filter_i_segment = get_segment(filter[2][0], filter[2][1], filter[2][2]);
        filtered = function(dir, k, j, i) {
          var res;
          res = k >= filter[0][0] && k <= filter[0][1] && j >= filter[1][0] && j <= filter[1][1] && i >= filter[2][0] && i <= filter[2][1] ? true : false;
          if (dir === 0) {
            res = i + 1 >= filter[2][0] && i + 1 <= filter[2][1] ? res : false;
          }
          if (dir === 1) {
            res = j + 1 >= filter[1][0] && j + 1 <= filter[1][1] ? res : false;
          }
          if (dir === 2) {
            res = k + 1 >= filter[0][0] && k + 1 <= filter[0][1] ? res : false;
          }
          return res;
        };
        filter_d = [filter_k_segment, filter_j_segment, filter_i_segment];
        borders = [[0, data.length - 1], [0, data[0].length - 1], [0, data[0][0].length - 1], [filter[0][0], filter[0][1]], [filter[1][0], filter[1][1]], [filter[2][0], filter[2][1]]];
      } else if (filter_scalar.length) {
        root.scalar = filter_scalar[0] + 2;
        filtered = function(dir, k, j, i) {
          var ci_lst, cj_lst, ck, ck_lst, fn2, len, q, res;
          res = false;
          ck_lst = dir !== 2 && k > 0 ? [-1, 0] : [0];
          cj_lst = dir !== 1 && j > 0 ? [-1, 0] : [0];
          ci_lst = dir !== 0 && i > 0 ? [-1, 0] : [0];
          if (k + 1 === k_last) {
            ck_lst.push(1);
          }
          if (j + 1 === j_last) {
            cj_lst.push(1);
          }
          if (i + 1 === i_last) {
            ci_lst.push(1);
          }
          if (!res) {
            fn2 = function(ck) {
              var cj, len1, results, t;
              if (!res) {
                results = [];
                for (t = 0, len1 = cj_lst.length; t < len1; t++) {
                  cj = cj_lst[t];
                  results.push((function(cj) {
                    var ci, len2, results1, u;
                    if (!res) {
                      results1 = [];
                      for (u = 0, len2 = ci_lst.length; u < len2; u++) {
                        ci = ci_lst[u];
                        results1.push((function(ci) {
                          var value;
                          value = data[k + ck][j + cj][i + ci][scalar];
                          if (value >= filter_scalar[1][0] && value <= filter_scalar[1][1]) {
                            return res = true;
                          }
                        })(ci));
                      }
                      return results1;
                    }
                  })(cj));
                }
                return results;
              }
            };
            for (q = 0, len = ck_lst.length; q < len; q++) {
              ck = ck_lst[q];
              fn2(ck);
            }
          }
          return res;
        };
        filter_d = [get_segment(0, k_last, 1), get_segment(0, j_last, 1), get_segment(0, i_last, 1)];
        borders = [[0, data.length - 1], [0, data[0].length - 1], [0, data[0][0].length - 1]];
      } else if (filter_list.length) {
        mask = (function() {
          var q, ref, results;
          results = [];
          for (x = q = 0, ref = data.length; 0 <= ref ? q < ref : q > ref; x = 0 <= ref ? ++q : --q) {
            results.push([]);
          }
          return results;
        })();
        fn2 = function(xk) {
          var ref1, results, t, xj;
          mask[xk] = (function() {
            var ref1, results, t;
            results = [];
            for (x = t = 0, ref1 = data[0].length; 0 <= ref1 ? t < ref1 : t > ref1; x = 0 <= ref1 ? ++t : --t) {
              results.push([]);
            }
            return results;
          })();
          results = [];
          for (xj = t = 0, ref1 = data[0].length; 0 <= ref1 ? t < ref1 : t > ref1; xj = 0 <= ref1 ? ++t : --t) {
            results.push((function(xj) {
              return mask[xk][xj] = (function() {
                var ref2, results1, u;
                results1 = [];
                for (u = 0, ref2 = data[0][0].length; 0 <= ref2 ? u < ref2 : u > ref2; 0 <= ref2 ? u++ : u--) {
                  results1.push(false);
                }
                return results1;
              })();
            })(xj));
          }
          return results;
        };
        for (xk = q = 0, ref = data.length; 0 <= ref ? q < ref : q > ref; xk = 0 <= ref ? ++q : --q) {
          fn2(xk);
        }
        fn3 = function(ind) {
          if (ind.length && mask.length > ind[2] && mask[ind[2]].length > ind[1] && mask[ind[2]][ind[1]].length > ind[0]) {
            return mask[ind[2]][ind[1]][ind[0]] = true;
          }
        };
        for (t = 0, len = filter_list.length; t < len; t++) {
          ind = filter_list[t];
          fn3(ind);
        }
        filtered = function(dir, k, j, i) {
          var ci_lst, cj_lst, ck, ck_lst, fn4, len1, res, u;
          res = false;
          ck_lst = dir !== 2 && k > 0 ? [-1, 0] : [0];
          cj_lst = dir !== 1 && j > 0 ? [-1, 0] : [0];
          ci_lst = dir !== 0 && i > 0 ? [-1, 0] : [0];
          if (k + 1 === k_last) {
            ck_lst.push(1);
          }
          if (j + 1 === j_last) {
            cj_lst.push(1);
          }
          if (i + 1 === i_last) {
            ci_lst.push(1);
          }
          if (!res) {
            fn4 = function(ck) {
              var cj, len2, results, v;
              if (!res) {
                results = [];
                for (v = 0, len2 = cj_lst.length; v < len2; v++) {
                  cj = cj_lst[v];
                  results.push((function(cj) {
                    var ci, len3, results1, w;
                    if (!res) {
                      results1 = [];
                      for (w = 0, len3 = ci_lst.length; w < len3; w++) {
                        ci = ci_lst[w];
                        results1.push((function(ci) {
                          if (mask[k + ck][j + cj][i + ci]) {
                            return res = true;
                          }
                        })(ci));
                      }
                      return results1;
                    }
                  })(cj));
                }
                return results;
              }
            };
            for (u = 0, len1 = ck_lst.length; u < len1; u++) {
              ck = ck_lst[u];
              fn4(ck);
            }
          }
          return res;
        };
        filter_d = [get_segment(0, k_last, 1), get_segment(0, j_last, 1), get_segment(0, i_last, 1)];
        borders = [[0, data.length - 1], [0, data[0].length - 1], [0, data[0][0].length - 1]];
      } else {
        filtered = function(k, j, i) {
          return false;
        };
        filter_d = [[], [], []];
        borders = [[0, data.length - 1], [0, data[0].length - 1], [0, data[0][0].length - 1]];
      }
      if (options.length < 1) {
        options = [false];
      }
      if (filter_options.length < 1) {
        filter_options = [false];
      }
      gen_lines(data, scale_coeff, d, directions, materials, borders, options[0], filtered, filter_d, filter_directions, filter_materials, filter_options[0]);
      if (!options[0] && !filter_options[0]) {
        gen_lines_seg(data, scale_coeff, d, directions, colors, borders, filtered, filter_d, filter_directions, filter_colors);
      } else {
        gen_lines_seg(data, scale_coeff, d, directions, colors, borders, filtered, filter_d, [false, false, false, false], filter_colors, options[0]);
        gen_lines_seg(data, scale_coeff, d, [directions[0], directions[1], directions[2], false], colors, borders, filtered, filter_d, [false, false, false, false], filter_colors);
        gen_lines_seg(data, scale_coeff, d, [false, false, false, false], colors, borders, filtered, filter_d, filter_directions, filter_colors, filter_options[0]);
        gen_lines_seg(data, scale_coeff, d, [false, false, false, false], colors, borders, filtered, filter_d, [filter_directions[0], filter_directions[1], filter_directions[2], false], filter_colors, filter_options[0]);
      }
      return [root.lines_seg, root.lines];
    }
  };

  root.GridFaces = {
    init: function(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials, filter_scalar, filter_list) {
      var n1, n2, n3;
      root.faces_geometry = new THREE.Geometry();
      root.faces_materials = [];
      root.faces_names = [];
      if (directions.length < 3) {
        directions = [false, false, false, false];
      }
      if (filter_directions.length < 3) {
        filter_directions = [true, true, true, true];
      }
      if (filter.length === 0 && filter_scalar.length === 0 && filter_list.length === 0) {
        gen_surfaces(data, scale_coeff, detail, directions, materials);
      } else if (filter.length > 2) {
        n1 = filter[0][0] !== filter[0][1] ? true : false;
        n2 = filter[1][0] !== filter[1][1] ? true : false;
        n3 = filter[2][0] !== filter[2][1] ? true : false;
        if ((n1 && n2) || (n1 && n3) || (n2 && n3)) {
          if (directions[0] || directions[1] || directions[2]) {
            gen_surfaces(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials);
          } else {
            gen_surfaces(data, scale_coeff, detail, filter_directions, filter_materials, filter);
          }
        }
      } else {
        gen_surfaces(data, scale_coeff, detail, directions, materials, filter, filter_directions, filter_materials, filter_scalar, filter_list);
      }
      root.faces = new THREE.Mesh(root.faces_geometry, new THREE.MeshFaceMaterial(root.faces_materials));
      return [root.faces, root.faces_names];
    }
  };

  root.GridPoints = {
    init: function(data, scale_coeff, variable, min, max, index, color, radius, options, types) {
      var calc_color, colors, fn, fn1, fn2, geometry, h, i, k, k_index, key, key_index, keys, len, len1, material, n, o, paletter, positions, q, ref, v0, v1;
      geometry = new THREE.BufferGeometry();
      root.cubes = new THREE.Object3D();
      paletter = [];
      fn = function(i) {
        return paletter.push(parseInt(color[i].substring(1), 16));
      };
      for (i = n = 0, ref = color.length - 1; 0 <= ref ? n <= ref : n >= ref; i = 0 <= ref ? ++n : --n) {
        fn(i);
      }
      variable = parseInt(variable) + 2;
      v0 = min[variable];
      v1 = max[variable];
      if (types.length > variable - 3 && !!types[variable - 3]) {
        h = types[variable - 3];
        keys = Object.keys(h);
        fn1 = function(key) {
          return h[key] = paletter[key_index];
        };
        for (key_index = o = 0, len = keys.length; o < len; key_index = ++o) {
          key = keys[key_index];
          fn1(key);
        }
        calc_color = function(value) {
          var b, c, g, r;
          c = h[value];
          r = c >> 16;
          g = (c & 0x00ff00) >> 8;
          b = c & 0x0000ff;
          return [r, g, b];
        };
      } else {
        calc_color = function(value) {
          var b, b0, b1, coeff, coeff_0, coeff_int, g, g0, g1, r, r0, r1;
          coeff = (value - v0) / (v1 - v0);
          coeff_int = Math.floor(coeff * (paletter.length - 1));
          r0 = paletter[coeff_int] >> 16;
          g0 = (paletter[coeff_int] & 0x00ff00) >> 8;
          b0 = paletter[coeff_int] & 0x0000ff;
          if (coeff_int === paletter.length - 1) {
            r = r0;
            g = g0;
            b = b0;
          } else {
            r1 = paletter[coeff_int + 1] >> 16;
            g1 = (paletter[coeff_int + 1] & 0x00ff00) >> 8;
            b1 = paletter[coeff_int + 1] & 0x0000ff;
            coeff_0 = coeff * (paletter.length - 1) - coeff_int;
            r = (r1 - r0) * coeff_0 + r0;
            g = (g1 - g0) * coeff_0 + g0;
            b = (b1 - b0) * coeff_0 + b0;
          }
          return [r, g, b];
        };
      }
      positions = [];
      colors = [];
      fn2 = function(k) {
        var j, j_index, len2, results, t;
        results = [];
        for (j_index = t = 0, len2 = k.length; t < len2; j_index = ++t) {
          j = k[j_index];
          results.push((function(j) {
            var i_index, len3, results1, u;
            results1 = [];
            for (i_index = u = 0, len3 = j.length; u < len3; i_index = ++u) {
              i = j[i_index];
              results1.push((function(i) {
                var b, g, r, ref1, sprite, sprite_material;
                if (options[0] || k_index === 0 || k_index === data.length - 1 || j_index === 0 || j_index === k.length - 1 || i_index === 0 || i_index === j.length - 1) {
                  positions.push(i[0], i[1], i[2]);
                  ref1 = calc_color(i[variable]), r = ref1[0], g = ref1[1], b = ref1[2];
                  colors.push(r / 255, g / 255, b / 255);
                  sprite_material = new THREE.SpriteMaterial({
                    color: (r << 16) + (g << 8) + b
                  });
                  sprite = new THREE.Sprite(sprite_material);
                  sprite.position.x = i[0] * scale_coeff;
                  sprite.position.y = i[1] * scale_coeff;
                  sprite.position.z = i[2] * scale_coeff;
                  sprite.scale.set(radius * 0.7, radius * 0.7, 1);
                  return root.cubes.add(sprite);
                }
              })(i));
            }
            return results1;
          })(j));
        }
        return results;
      };
      for (k_index = q = 0, len1 = data.length; q < len1; k_index = ++q) {
        k = data[k_index];
        fn2(k);
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
      material = new THREE.PointsMaterial({
        vertexColors: THREE.VertexColors,
        size: radius * 2,
        sizeAttenuation: true
      });
      root.points = new THREE.Points(geometry, material);
      root.points.scale.set(scale_coeff, scale_coeff, scale_coeff);
      root.points.sortParticles = true;
      return [root.points, root.cubes];
    }
  };

}).call(this);
