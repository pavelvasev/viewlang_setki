import "obj"

Scene 
{
	id: thescene
	text: ""
	
	property var script_gui_flag: false
	property var script_grid_flag: false
	property var script_lib_flag_1: false
	property var script_lib_flag_2: false
	property var script_lib_flag_3: false
	property var script_styles_flag: false

	property var redef_flag: false

	property var q: script_init()

	property var url_files: []

	function script_init()
	{
		if ( !script_gui_flag )
			la_require( 
				$basePath + "lib/dat.gui/build/dat.gui.min.js",
				function() { 
					
					// add remove folder function
					dat.GUI.prototype.removeFolder = function(name) {
						var folder = this.__folders[name];
						if (!folder) return;
						folder.close();
						this.__ul.removeChild(folder.domElement.parentNode);
						delete this.__folders[name];
						this.onResize();
					}

					if ( !script_gui_flag && !script_styles_flag )
						la_require( 
							$basePath + "js/styles.js", 
							function(){ script_styles_flag = true; });

					script_gui_flag = true;
				});

		if( !script_lib_flag_1 )
			la_require(
				$basePath + 
				"lib/three.js/examples/js/renderers/Projector.js",
				function() { script_lib_flag_1 = true; });

		if( !script_lib_flag_2 )
			la_require(
				$basePath + 
				"lib/three.js/examples/js/renderers/SVGRenderer.js",
				function() { script_lib_flag_2 = true; });

		if( !script_lib_flag_3 )
			la_require(
				$basePath + 
				"lib/FileSaver.js/FileSaver.min.js",
				function() { script_lib_flag_3 = true; });

		if ( !script_grid_flag )
			la_require( 
				$basePath + "js/grid.js", 
				function() { script_grid_flag = true; });

		renderer.setClearColor( 0xeeeeee, 1 );

		if ( !redef_flag ) {
			var animate_func = animate;

			animate = function () {
				animate_func();
				sprite_upd();
			}

			redef_flag = true;

			var lst = [];
			var prs = window.location.hash.split(/"/);
			
			for (var i = 0; i < prs.length; i++)
			{
				if (prs[i] == "Grid-file") {
					for (var j = i + 2; j < prs.length; j += 2) {
						if (prs[j].indexOf("http") == 0) lst.push(prs[j]);
					}
					
					break;
				}
			}

			url_files = lst;
		}
	}

	FileParam
	{
		id: inputFile
		text: "Grid file:"
		file: Qt.resolvedUrl( "../data/ris5.dat" )
		multiple: true
	}

	property var settings: { style_default: true }

	Load
	{
		id: loader
		files: (url_files.length)? url_files: inputFile.files

		onStatusChanged: {
			data_counter = 0;
			data_controls = {};
			url_files = [];

			inputFile.children[0].children[2].y = 90;
		}
	}

	Axis 
	{ 
		id: axis
	}

	function sprite_upd() {
		if (!!axis && 
			!!axis.caption_obj_x && !!axis.caption_obj_y && !! axis.caption_obj_z)
		{
			var scale;

			scale = Math.sqrt(
				Math.pow(camera.position.x - axis.caption_obj_x.position.x, 2) + 
				Math.pow(camera.position.y - axis.caption_obj_x.position.y, 2) + 
				Math.pow(camera.position.z - axis.caption_obj_x.position.z, 2)) / 4;

			axis.caption_obj_x.scale.x = scale;
			axis.caption_obj_x.scale.y = scale / 4;

			scale = Math.sqrt(
				Math.pow(camera.position.x - axis.caption_obj_y.position.x, 2) + 
				Math.pow(camera.position.y - axis.caption_obj_y.position.y, 2) + 
				Math.pow(camera.position.z - axis.caption_obj_y.position.z, 2)) / 4;

			axis.caption_obj_y.scale.x = scale;
			axis.caption_obj_y.scale.y = scale / 4;

			scale = Math.sqrt(
				Math.pow(camera.position.x - axis.caption_obj_z.position.x, 2) + 
				Math.pow(camera.position.y - axis.caption_obj_z.position.y, 2) + 
				Math.pow(camera.position.z - axis.caption_obj_z.position.z, 2)) / 4;

			axis.caption_obj_z.scale.x = scale;
			axis.caption_obj_z.scale.y = scale / 4;
		}
	}

	Repeater
	{
		id: grid
		model: loader.status

		property var gui
		property var q: init_controls()

		property var f_blocks
		property var f_visible
		property var f_detail
		property var f_filter
		property var f_points
		property var f_export
		property var f_caption

		property var controls: {}
		property var d_controls: {}
		property var s_controls: {}
		property var fs_controls: {}
		property var id_controls: []

		property var filter_block: -1
		property var filter_detail_i: [0, 1, 1]
		property var filter_detail_j: [0, 1, 1]
		property var filter_detail_k: [0, 1, 1]
		property var items_filter: []

		property var style_default: true
		property var style_filter_default: true

		property var l_directions: [true, true, true, true]
		property var l_colors: 
			["#ffffff", "#ffffff", "#ffffff", "#000000"]
		property var l_options: [false, false] //[false, true]

		property var l_filter_directions: [true, true, true, true]
		property var l_filter_colors: 
			["#000000", "#000000", "#000000", "#0000ff"]
		property var l_filter_options: [false, true]

		property var f_directions: [false, false, false, false]
		property var f_colors: ["#00ffff", "#ff00ff", "#ffff00"]
		property var f_options: [0.2]

		property var f_filter_directions: [true, true, true, true]
		property var f_filter_colors: ["#00ff88", "#8800ff", "#ff8800"]
		property var f_filter_options: [0.2]

		property var state_l_materials: 0
		property var state_l_directions: 0

		property var state_f_materials: 0
		property var state_f_directions: 0

		property var filter_controls_changed: 0

		property var points_variable: ""
		property var points_size: 0.25
		property var point: []
		property var point_size: 0.25
		property var point_ind: []

		property var points_options: [false]

		property var counter: 0

		property var filter_scalar: -1
		property var filter_scalar_range: [0, 0]

		property var filter_list: []

		property var export_buttons: []

		onModelChanged: {
			grid.style_default = thescene.settings.style_default;
			s_controls["Default Style"] = thescene.settings.style_default;
		}

		onState_l_materialsChanged: {		

			l_colors = [
				s_controls["lines i color"], 
				s_controls["lines j color"], 
				s_controls["lines k color"], 
				s_controls["border color"]];
			l_options = [
				s_controls["lines dashed"], 
				s_controls["border bold"]];
			
			l_filter_colors = [
				fs_controls["lines i color"], 
				fs_controls["lines j color"], 
				fs_controls["lines k color"], 
				fs_controls["border color"]]
			l_filter_options = [
				fs_controls["lines dashed"], 
				fs_controls["border bold"]];
		}

		onState_l_directionsChanged: {

			if (style_default != s_controls["Default Style"])
				style_default = s_controls["Default Style"];
			if (style_filter_default != fs_controls["Default Style"])
				style_filter_default = fs_controls["Default Style"];
			
			l_directions = [
				s_controls["lines i"], 
				s_controls["lines j"],
				s_controls["lines k"],
				s_controls["internal"]];

			l_filter_directions = [
				fs_controls["lines i"], 
				fs_controls["lines j"],
				fs_controls["lines k"],
				fs_controls["internal"]];
		}

		onState_f_materialsChanged: {
			
			if (style_default != s_controls["Default Style"])
				style_default = s_controls["Default Style"];
			if (style_filter_default != fs_controls["Default Style"])
				style_filter_default = fs_controls["Default Style"];		

			f_colors = [
				s_controls["faces ij color"], 
				s_controls["faces ik color"], 
				s_controls["faces jk color"] ];
			f_options = [
				s_controls["faces opacity"]];

			f_filter_colors = [
				fs_controls["faces ij color"], 
				fs_controls["faces ik color"], 
				fs_controls["faces jk color"] ];
			f_filter_options = [
				fs_controls["faces opacity"]];
		}

		onState_f_directionsChanged: {
			f_directions = [
				s_controls["faces ij"], 
				s_controls["faces ik"], 
				s_controls["faces jk"],
				s_controls["internal faces"]];

			f_filter_directions = [
				fs_controls["faces ij"], 
				fs_controls["faces ik"], 
				fs_controls["faces jk"],
				fs_controls["internal faces"]];
		}

		onPoints_variableChanged: {
			for (var i = 0; i < export_buttons.length; i ++)
				f_export.remove(export_buttons[i]);

			export_buttons = [];

			if (points_variable != "") {
				var c = f_export.add(grid.controls, "Legend *.png");
				export_buttons.push(c);
				c = f_export.add(grid.controls, "Legend *.svg");
				export_buttons.push(c);
			}
		}

		function save_file(type, obj, name)
		{
			if (type == "png")
			{
				var canvas = obj;

				try {
					var isFileSaverSupported = !!new Blob;
							
					var ctx = canvas.getContext("2d");

					var binary = atob(
						canvas.toDataURL("image/png").replace(
							/^data:image\/(png|jpg);base64,/, "")
						);

					var raw_buffer = new ArrayBuffer(binary.length);
					var integers = new Uint8Array(raw_buffer);
								
					for (var i = 0; i < binary.length; i++)
						integers[i] = binary.charCodeAt(i);

					binary = raw_buffer;

					var blob = new Blob([binary], {type: 'image/png'});
							
					saveAs(blob, name + ".png");

				} catch (e) {
					window.open(canvas.toDataURL());
				}
			} 
			else if (type == "svg")
			{
				var svg = obj;

				var serializer = new XMLSerializer();
				var svg_blob = new Blob([serializer.serializeToString(svg)], 
					{'type': "image/svg+xml"});

				try {
					var isFileSaverSupported = !!new Blob;
					saveAs(svg_blob, name + ".svg");
				} catch (e) {
					var url = URL.createObjectURL(svg_blob);
					window.open(url);
				}
			}
		}

		function init_controls()
		{
			if ( script_gui_flag && script_lib_flag_1 && script_lib_flag_2 )
			{
				gui = new dat.GUI( { width: 350 } );

				f_caption = gui.addFolder('Scene');

				f_blocks = gui.addFolder('Blocks');

				f_visible = f_blocks.addFolder("Visible");
				f_detail = f_blocks.addFolder("Detail");

				s_controls["all/none"] = function () {
					if (s_controls["lines i"] || s_controls["lines j"] || 
						s_controls["lines k"]) {
						s_controls["lines i"] = false;
						s_controls["lines j"] = false;
						s_controls["lines k"] = false;
					} else {
						s_controls["internal"] = true;
						s_controls["lines i"] = true;
						s_controls["lines j"] = true;
						s_controls["lines k"] = true;
					}

					grid.state_l_directions = 
						(grid.state_l_directions != 0)? 0: 1;
				}

				s_controls["lines i"] = true;
				s_controls["lines j"] = true;
				s_controls["lines k"] = true;
				s_controls["lines i color"] = "#ffffff";
				s_controls["lines j color"] = '#ffffff';
				s_controls["lines k color"] = '#ffffff';
				s_controls["lines dashed"] = false;
				s_controls["border color"] = '#000000';
				s_controls["border bold"] = true;
				s_controls["internal"] = true;

				s_controls["all/none faces"] = function () {
					if (s_controls["faces ij"] || s_controls["faces ik"] || 
						s_controls["faces jk"]) {
						s_controls["faces ij"] = false;
						s_controls["faces ik"] = false;
						s_controls["faces jk"] = false;
					} else {
						s_controls["internal"] = true;
						s_controls["faces ij"] = true;
						s_controls["faces ik"] = true;
						s_controls["faces jk"] = true;
					}

					grid.state_f_directions = 
						(grid.state_f_directions != 0)? 0: 1;
				}
				
				s_controls["faces ij"] = false;
				s_controls["faces ik"] = false;
				s_controls["faces jk"] = false;
				s_controls["faces ij color"] = '#00ffff';
				s_controls["faces ik color"] = '#ff00ff';
				s_controls["faces jk color"] = '#ffff00';
				s_controls["internal faces"] = true;
				s_controls["faces opacity"] = 0.2;

				s_controls["Default Style"] = true;

				var c = f_blocks.add(s_controls, "Default Style").listen();

				c.onFinishChange(function(value)
				{ 
					if ( value ) 
					{
						f_blocks.removeFolder("Lines Style");
						f_blocks.removeFolder("Faces Style");
					} 
					else 
					{
						grid.add_style_folders();
						
						grid.state_l_directions = 
							(grid.state_l_directions != 0)? 0: 1;
						grid.state_f_directions = 
							(grid.state_f_directions != 0)? 0: 1;
					}
					grid.style_default = value;

					thescene.settings.style_default = value;
				});	

				fs_controls["all/none"] = function () {
					if (fs_controls["lines i"] || fs_controls["lines j"] || 
						fs_controls["lines k"]) {
						fs_controls["lines i"] = false;
						fs_controls["lines j"] = false;
						fs_controls["lines k"] = false;
					} else {
						fs_controls["internal"] = true;
						fs_controls["lines i"] = true;
						fs_controls["lines j"] = true;
						fs_controls["lines k"] = true;
					}

					grid.state_l_directions = 
						(grid.state_l_directions != 0)? 0: 1;
				};

				fs_controls["lines i"] = true;
				fs_controls["lines j"] = true;
				fs_controls["lines k"] = true;
				fs_controls["lines i color"] = "#000000";
				fs_controls["lines j color"] = '#000000';
				fs_controls["lines k color"] = '#000000';
				fs_controls["lines dashed"] = false;
				fs_controls["border color"] = '#0000ff';
				fs_controls["border bold"] = true;
				fs_controls["internal"] = true;

				fs_controls["all/none faces"] = function () {
					if (fs_controls["faces ij"] || fs_controls["faces ik"] || 
						fs_controls["faces jk"]) {
						fs_controls["faces ij"] = false;
						fs_controls["faces ik"] = false;
						fs_controls["faces jk"] = false;
					} else {
						fs_controls["internal"] = true;
						fs_controls["faces ij"] = true;
						fs_controls["faces ik"] = true;
						fs_controls["faces jk"] = true;
					}

					grid.state_f_directions = 
						(grid.state_f_directions != 0)? 0: 1;
				}
				
				fs_controls["faces ij"] = true;
				fs_controls["faces ik"] = true;
				fs_controls["faces jk"] = true;
				fs_controls["faces ij color"] = '#00ff88';
				fs_controls["faces ik color"] = '#8800ff';
				fs_controls["faces jk color"] = '#ff8800';
				fs_controls["internal faces"] = true;
				fs_controls["faces opacity"] = 0.2;

				fs_controls["Default Style"] = true;

				f_points = gui.addFolder('Points');
				f_filter = gui.addFolder('Filter');

				grid.controls["About"] = function() {
					about_dialog.open();
				}				

				grid.controls["Axis"] = true;
				
				grid.controls["X"] = "X";
				grid.controls["Y"] = "Y";
				grid.controls["Z"] = "Z";
				
				grid.controls["Font"] = "Normal 14pt Arial";

				grid.controls["Background"] = '#eeeeee';

				f_caption.add(grid.controls, "About");

				f_caption.add(grid.controls, "Axis").onFinishChange(
					function(value){ axis.visible = value; });

				f_caption.add(grid.controls, "X").onFinishChange(
					function(value){ axis.x_text = value; });
				
				f_caption.add(grid.controls, "Y").onFinishChange(
					function(value){ axis.y_text = value; });

				f_caption.add(grid.controls, "Z").onFinishChange(
					function(value){ axis.z_text = value; });

				f_caption.add(grid.controls, "Font").onFinishChange(
					function(value){ axis.font = value; });

				f_caption.addColor(grid.controls, "Background").onChange(
					function(value){
						renderer.setClearColor( 
							parseInt(value.substring(1), 16), 1 );
					});

				f_export = gui.addFolder('Export');

				grid.controls["*.png"] = function() {
					save_file("png", $("body").children("canvas")[0], "grid");
				};

				grid.controls["*.svg [slow]"] = function() {
					renderer_SVG = new THREE.SVGRenderer();

					renderer_SVG.setSize(window.innerWidth, window.innerHeight);

					var cubes = [];

					for ( var i = 0; i < grid['$items'].length; i++ )
					{
						if(grid['$items'][i].children[2]['$properties']['visible'].val
							&& !! grid['$items'][i].children[2]['$properties']['cubes'].val )
						{
							cubes.push(
								grid['$items'][i].children[2]['$properties']['cubes'].val);
						}
					}

					var lines = [];

					for ( var i = 0; i < grid['$items'].length; i++ )
					{
						if(grid['$items'][i].children[0]['$properties']['visible'].val
							&& !! grid['$items'][i].children[0]['$properties']['lines'].val )
						{
							lines.push(
								grid['$items'][i].children[0]['$properties']['lines'].val);
						}
					}

					if(cubes.length > 0 || lines.length > 0 || (!!axis && axis.visible))
					{
						var svgscene = jQuery.extend(true, {}, scene);

						if(cubes.length > 0)
							for (var i = 0; i < cubes.length; i++)
								svgscene.add(cubes[i]);

						if(lines.length > 0)
							for (var i = 0; i < lines.length; i++)
								svgscene.add(lines[i]);

						if(!!axis && axis.visible)
							svgscene.add(axis.axis_obj);

						renderer_SVG.render(svgscene, camera);
						svgscene = undefined;
					}
					else
					{
						renderer_SVG.render(scene, camera);
					}

					document.body.appendChild( renderer_SVG.domElement );

					if (!!axis && axis.visible) {

						var w2 = window.innerWidth / 2;
						var h2 = window.innerHeight / 2;

						new_caption = function (v, w2, h2, caption) {
							v.project(camera);
							
							var x = ( v.x * w2 );
							var y = - ( v.y * h2 );

							var svgns = "http://www.w3.org/2000/svg";
							var text;

							text = document.createElementNS(svgns, 'text');
							
							text.setAttributeNS(null, 'x', x);
							text.setAttributeNS(null, 'y', y);
							text.setAttributeNS(null, 'fill', '#000000');
							text.setAttributeNS(null, 'text-anchor', 'center');
							text.setAttributeNS(null, 'style', 'font: ' + axis.font);
							text.appendChild(document.createTextNode(caption));

							return text;
						};

						var text_x = new_caption(new THREE.Vector3(axis.r - 1, -2, 0), 
							w2, h2, axis.x_text);
						var text_y = new_caption(new THREE.Vector3(0, axis.r - 2, -1), 
							w2, h2, axis.y_text);
						var text_z = new_caption(new THREE.Vector3(0, -2, axis.r - 1), 
							w2, h2, axis.z_text);

						var svgimg = $("body").children("svg")[0];

						svgimg.appendChild(text_x);
						svgimg.appendChild(text_y);
						svgimg.appendChild(text_z);
					}

					save_file("svg", $("body").children("svg")[0], "grid");
					document.body.removeChild( renderer_SVG.domElement );
				};

				grid.controls["Legend *.png"] = function() {
					if (grid.points_variable != "") 
						save_file("png", legend.dom.firstChild.childNodes[0], "legend");
				};

				grid.controls["Legend *.svg"] = function() {
					if (grid.points_variable != "") 
						save_file("svg", legend.dom.firstChild.childNodes[1], "legend");
				};

				f_export.add(grid.controls, "*.png");
				f_export.add(grid.controls, "*.svg [slow]");
			}
		}

		function add_style_controls(f_lines, f_faces, controls)
		{
			var change_l_m = function(value) { 
				grid.state_l_materials =
					(grid.state_l_materials != 0)? 0: 1; }
			var change_l_d = function(value) {
				grid.state_l_directions = 
					(grid.state_l_directions != 0)? 0: 1; }

			var change_f_m = function(value) { 
				grid.state_f_materials =
					(grid.state_f_materials != 0)? 0: 1; }
			var change_f_d = function(value) {
				grid.state_f_directions = 
					(grid.state_f_directions != 0)? 0: 1; }

			f_lines.add(controls, "all/none");	
			f_lines.add(controls, "lines i").onFinishChange(change_l_d).listen(); 
			f_lines.add(controls, "lines j").onFinishChange(change_l_d).listen(); 
			f_lines.add(controls, "lines k").onFinishChange(change_l_d).listen(); 
			f_lines.addColor(controls, "lines i color").onChange(change_l_m); 
			f_lines.addColor(controls, "lines j color").onChange(change_l_m); 
			f_lines.addColor(controls, "lines k color").onChange(change_l_m);
			f_lines.add(controls, "internal").onFinishChange(change_l_d).listen();
			f_lines.add(controls, "lines dashed").onFinishChange(change_l_m); 
			f_lines.addColor(controls, "border color").onChange(change_l_m); 
			//f_lines.add(controls, "border bold").onFinishChange(change_l_m); 
			
			f_faces.add(controls, "all/none faces");
			f_faces.add(controls, "faces ij").onFinishChange(change_f_d).listen();
			f_faces.add(controls, "faces ik").onFinishChange(change_f_d).listen();
			f_faces.add(controls, "faces jk").onFinishChange(change_f_d).listen();
			f_faces.addColor(controls, "faces ij color").onChange(change_f_m);
			f_faces.addColor(controls, "faces ik color").onChange(change_f_m);
			f_faces.addColor(controls, "faces jk color").onChange(change_f_m);
			f_faces.add(controls, "internal faces").onFinishChange(change_f_d).listen();
			f_faces.add(controls, "faces opacity", 0, 1).step(0.05)
				.onFinishChange(change_f_m);
		}

		function add_style_folders()
		{
			f_blocks.removeFolder("Lines Style");
			f_blocks.removeFolder("Faces Style");

			var f_lines = f_blocks.addFolder("Lines Style");
			var f_faces = f_blocks.addFolder("Faces Style");

			add_style_controls(f_lines, f_faces, s_controls);
		}

		function add_fstyle_folders()
		{
			var f_lines = f_filter.addFolder("Lines Style");
			var f_faces = f_filter.addFolder("Faces Style");

			add_style_controls(f_lines, f_faces, fs_controls);
		}

		Item
		{
			id: block
			property var z: index

			property var q: add_controls()

			property var option_visible: true
			property var option_detail: [
					Math.floor(loader.grid[ index ].length / 35) + 1,
					Math.floor(loader.grid[ index ][0].length / 35) + 1,
					Math.floor(loader.grid[ index ][0][0].length / 35) + 1
				]

			function filter_upd(value)
			{
				grid.fs_controls["faces ij"] = true;
				grid.fs_controls["faces ik"] = true;
				grid.fs_controls["faces jk"] = true;

				if (grid.s_controls["internal"])
				{
					grid.filter_controls_changed |= 1;
					grid.s_controls["internal"] = false;
				}
							
				if (grid.s_controls["Default Style"])
				{
					grid.filter_controls_changed |= 2;
					grid.s_controls["Default Style"] = false;
					grid.style_default = false;

					grid.add_style_folders();
				}
							
				grid.state_l_directions = 
					(grid.state_l_directions != 0)? 0: 1;

				grid.state_f_directions = 
					(grid.state_f_directions != 0)? 0: 1;

				grid.filter_block = value - 1;

				while(grid.items_filter.length > 0)
				{
					var c = grid.items_filter.pop();
					grid.f_filter.remove(c);
				}

				grid.f_filter.removeFolder("Lines Style");
				grid.f_filter.removeFolder("Faces Style");

				var c, t, l; 

				l = loader.grid[value - 1][0][0].length;
				t = "i (" + l.toString() + ")";
				grid.controls[t] = 
					"from " + (grid.filter_detail_i[0] + 1).toString() + 
					" to " + (grid.filter_detail_i[1] + 1).toString() + 
					" by " + (grid.filter_detail_i[2]).toString();
				c = grid.f_filter.add(grid.controls, t).listen();
				grid.items_filter.push(c);

				c.onFinishChange(function(value)
				{ 
					var numb = value.match(/\d+/g);
						
					if(!!numb) {
						var tmp = [1, 1, 1];
						if (numb.length > 0) tmp[0] = parseInt(numb[0]) - 1;
						if (numb.length > 1) tmp[1] = parseInt(numb[1]) - 1;
							else tmp[1] = tmp[0] + 1;
						if (numb.length > 2) tmp[2] = parseInt(numb[2]) - 1;
						grid.filter_detail_i = [tmp[0], tmp[1], tmp[2]];
					} else {
						l = loader.grid[
							grid.filter_block][0][0].length;
						grid.filter_detail_i = [0, l - 1, 1];

						t = "i (" + l.toString() + ")";
						grid.controls[t] = 
							"from 1 to " + l.toString() + " by 1";
					}
				});

				l = loader.grid[value - 1][0].length;
				t = "j (" + l.toString() + ")";
				grid.controls[t] = 
					"from " + (grid.filter_detail_j[0] + 1).toString() + 
					" to " + (grid.filter_detail_j[1] + 1).toString() + 
					" by " + (grid.filter_detail_j[2]).toString();
				c = grid.f_filter.add(grid.controls, t).listen();
				grid.items_filter.push(c);

				c.onFinishChange(function(value)
				{ 
					var numb = value.match(/\d+/g);
				
					if(!!numb) {
						var tmp = [1, 1, 1];
						if (numb.length > 0) tmp[0] = parseInt(numb[0]) - 1;
						if (numb.length > 1) tmp[1] = parseInt(numb[1]) - 1;
							else tmp[1] = tmp[0] + 1;
						if (numb.length > 2) tmp[2] = parseInt(numb[2]) - 1;
						grid.filter_detail_j = [tmp[0], tmp[1], tmp[2]];
					} else {
						l = loader.grid[grid.filter_block][0].length;
						grid.filter_detail_j = [0, l - 1, 1];

						t = "j (" + l.toString() + ")";
						grid.controls[t] = 
							"from 1 to " + l.toString() + " by 1";
					}
				});

				l = loader.grid[value - 1].length;
				t = "k (" + l.toString() + ")";
				grid.controls[t] = 
					"from " + (grid.filter_detail_k[0] + 1).toString() + 
					" to " + (grid.filter_detail_k[1] + 1).toString() + 
					" by " + (grid.filter_detail_k[2]).toString();
				c = grid.f_filter.add(grid.controls, t).listen();
				grid.items_filter.push(c);

				c.onFinishChange(function(value)
				{ 
					var numb = value.match(/\d+/g);
				
					if(!!numb) {
						var tmp = [1, 1, 1];
						if (numb.length > 0) tmp[0] = parseInt(numb[0]) - 1;
						if (numb.length > 1) tmp[1] = parseInt(numb[1]) - 1;
							else tmp[1] = tmp[0] + 1;
						if (numb.length > 2) tmp[2] = parseInt(numb[2]) - 1;
						grid.filter_detail_k = [tmp[0], tmp[1], tmp[2]];
					} else {
						l = loader.grid[grid.filter_block].length;
						grid.filter_detail_k = [0, l - 1, 1];

						t = "k (" + l.toString() + ")";
						grid.controls[t] = "from 1 to " + 
							l.toString() + " by 1";
					}
				});

				filter_styles_upd();
			}

			function filter_cells_upd(value)
			{
				if (grid.s_controls["lines i"])
				{
					grid.filter_controls_changed |= 4;
					grid.s_controls["lines i"] = false;
				}

				if (grid.s_controls["lines j"])
				{
					grid.filter_controls_changed |= 8;
					grid.s_controls["lines j"] = false;
				}

				if (grid.s_controls["lines k"])
				{
					grid.filter_controls_changed |= 16;
					grid.s_controls["lines k"] = false;
				}

				if (grid.s_controls["Default Style"])
				{
					grid.filter_controls_changed |= 2;
					grid.s_controls["Default Style"] = false;
					grid.style_default = false;

					grid.add_style_folders();
				}

				if (grid.fs_controls["faces ij"] || 
					grid.fs_controls["faces ik"] || 
					grid.fs_controls["faces ik"])
				{
					grid.fs_controls["faces ij"] = false;
					grid.fs_controls["faces ik"] = false;
					grid.fs_controls["faces jk"] = false;

					grid.state_f_directions = 
							(grid.state_f_directions != 0)? 0: 1;
				}

				if (grid.fs_controls["Default Style"])
				{
					grid.fs_controls["Default Style"] = false;
					grid.style_filter_default = false;

					grid.add_fstyle_folders();
				}
			}

			function filter_styles_upd()
			{
				var c = grid.f_filter.add(grid.fs_controls, "Default Style");

				if ( !grid.style_filter_default ) grid.add_fstyle_folders();

				c.onFinishChange(function(value)
				{ 
					if ( value ) 
					{
						grid.f_filter.removeFolder("Lines Style");
						grid.f_filter.removeFolder("Faces Style");
					}
					else
					{
						grid.add_fstyle_folders();
						grid.state_l_directions = 
							(grid.state_l_directions != 0)? 0: 1;
						grid.state_f_directions = 
							(grid.state_f_directions != 0)? 0: 1;
					}

					grid.style_filter_default = value;
				});

				grid.items_filter.push(c);	
			}

			function filter_scalar_upd(value)
			{
				filter_cells_upd();

				for ( var i = 0; i < grid['$items'].length; i++ )
					grid['$items'][i].option_detail = [1, 1, 1];

				for ( k in grid.d_controls )
					grid.d_controls[k] = 'di = 1, dj = 1, dk = 1';
							
				grid.state_l_directions = 
					(grid.state_l_directions != 0)? 0: 1;

				grid.filter_scalar = value;

				while(grid.items_filter.length > 0)
				{
					var c = grid.items_filter.pop();
					grid.f_filter.remove(c);
				}

				grid.f_filter.removeFolder("Lines Style");
				grid.f_filter.removeFolder("Faces Style");

				var a = loader.min[value + 2]; 
				var b = loader.max[value + 2];

				var a_name = "min";
				var b_name = "max";

				grid.controls[a_name] = grid.filter_scalar_range[0];
				grid.controls[b_name] = grid.filter_scalar_range[1];

				var step = (!!loader.types[value - 1])? 1: 0.0001;
				
				var c;

				c = grid.f_filter.add(grid.controls, a_name, a, b).step(step);

				c.onFinishChange(function(value)
				{
					grid.filter_scalar_range = [
						value, grid.filter_scalar_range[1]];
				});

				grid.items_filter.push(c);

				c = grid.f_filter.add(grid.controls, b_name, a, b).step(step);

				c.onFinishChange(function(value)
				{
					grid.filter_scalar_range = [
						grid.filter_scalar_range[0], value];
				});

				grid.items_filter.push(c);

				filter_styles_upd();
			}

			function filter_list_upd(value) {
				filter_cells_upd();

				for ( var i = 0; i < grid['$items'].length; i++ )
					grid['$items'][i].option_detail = [1, 1, 1];

				for ( k in grid.d_controls )
					grid.d_controls[k] = 'di = 1, dj = 1, dk = 1';

				grid.state_l_directions = 
					(grid.state_l_directions != 0)? 0: 1;

				while(grid.items_filter.length > 0)
				{
					var c = grid.items_filter.pop();
					grid.f_filter.remove(c);
				}

				grid.f_filter.removeFolder("Lines Style");
				grid.f_filter.removeFolder("Faces Style");

				grid.controls["set list"] = function() {
					var new_text = "";

					for (var i = 0; i < grid.filter_list.length; i++) {
						var new_text_block = "";
						
						for (var j = 0; j < grid.filter_list[i].length; j++) {
							if (new_text_block.length > 0) new_text_block += ", ";

							new_text_block += 
								(i + 1).toString() + " " +
								(grid.filter_list[i][j][0] + 1).toString() + " " +
								(grid.filter_list[i][j][1] + 1).toString() + " " +
								(grid.filter_list[i][j][2] + 1).toString();
						}

						new_text += new_text_block + "\n";
					}

					list_dialog_text.text = new_text;

					list_dialog.open();
				};

				var c = grid.f_filter.add(grid.controls, "set list");

				grid.items_filter.push(c);

				var new_filter_list = [];

				for (var i = 0; i < loader.status; i++) {
					var lst_i = [];
					
					for (var j = 0; j < loader.grid[i].length; j++){
						var a = loader.grid[i][0][0].length - 1;
						var b = loader.grid[i][0].length - 1;
						
						lst_i.push([0, 0, j]);
						lst_i.push([a, 0, j]);
						lst_i.push([0, b, j]);
						lst_i.push([a, b, j]);
					}
					
					for (var j = 0; j < loader.grid[i][0].length; j++){
						var a = loader.grid[i][0][0].length - 1;
						var b = loader.grid[i].length - 1;
						
						lst_i.push([0, j, 0]);
						lst_i.push([a, j, 0]);
						lst_i.push([0, j, b]);
						lst_i.push([a, j, b]);
					}

					for (var j = 0; j < loader.grid[i][0][0].length; j++){
						var a = loader.grid[i][0].length - 1;
						var b = loader.grid[i].length - 1;
						
						lst_i.push([j, 0, 0]);
						lst_i.push([j, a, 0]);
						lst_i.push([j, 0, b]);
						lst_i.push([j, a, b]);
					}

					new_filter_list.push(lst_i);
				}

				grid.filter_list = new_filter_list;

				filter_styles_upd();
			}

			function add_controls()
			{
				if (data_counter == 0 && grid.id_controls.length > 0) {

					while(grid.id_controls.length > 0)
					{
						var c = grid.id_controls.pop();
						c[0].remove(c[1]);
					}

					while(grid.items_filter.length > 0)
					{
						var c = grid.items_filter.pop();
						grid.f_filter.remove(c);
					}

					grid.f_filter.removeFolder("Lines Style");
					grid.f_filter.removeFolder("Faces Style");

					data_controls = {};

					block.option_visible = true;
				}

				var name = "#" + (block.z + 1).toString() + 
					(loader.grid[ block.z ].blockname || "visible"); 

				grid.controls[ name ] = true;

				data_controls[block.z] = [[name, 
					function(value){ 
						block.option_visible = value;
					}]];

				var d = [
					loader.grid[ block.z ].length, 
					loader.grid[ block.z ][0].length, 
					loader.grid[ block.z ][0][0].length]

				name = '#' + (block.z + 1).toString() + " (" + 
					d[2].toString() + ", " + 
					d[1].toString() + ", " +
					d[0].toString() + ")";

				for (var i = 0; i < 3; i++) 
					d[i] = Math.floor(d[i] / 35) + 1;

				grid.d_controls[ name ] = "di = " +
					d[2].toString() + ", dj = " + 
					d[1].toString() + ", dk = " +
					d[0].toString();

				block.option_detail = d;

				data_controls[block.z][1] = [name, 
					function(value){ 
						var numb = value.match(/\d+/g);
						
						if(!!numb && numb.length >= 3) {
							block.option_detail = [ 
								parseInt(numb[2]), 
								parseInt(numb[1]), 
								parseInt(numb[0]) ];
						} else {
							block.option_detail = [1, 1, 1];
							value =	'di = 1, dj = 1, dk = 1';
						}
					}];
				
				if (data_counter == loader.grid.length - 1) {

					var keys = Object.keys(data_controls);

					for (var i = 0; i < keys.length; i++)
					{
						var item, c;
						
						item = data_controls[i][0];
						c = grid.f_visible.add(grid.controls, item[0]);
						c.onFinishChange(item[1]);
						grid.id_controls.push([grid.f_visible, c]);

						item = data_controls[i][1];
						c = grid.f_detail.add(grid.d_controls, item[0]).listen();
						c.onFinishChange(item[1]);
						grid.id_controls.push([grid.f_detail, c]);
					}

					data_controls = {};
					
					grid.controls["all points"] = function() {
						for ( var i = 0; i < grid['$items'].length; i++ )
							grid['$items'][i].option_detail = [1, 1, 1];

						for ( k in grid.d_controls )
							grid.d_controls[k] = 'di = 1, dj = 1, dk = 1';
					};

					var c = grid.f_detail.add(grid.controls, "all points");

					grid.id_controls.push([grid.f_detail, c]);

					// points

					grid.point = [];
					grid.points_variable = "";

					if (loader.grid[0][0][0][0].length > 3) {

						grid.controls["variable"] = "";

						var lst = [""];

						for ( var i = 1; i <= loader.grid[0][0][0][0].length - 3; i++ ) 
							lst.push(i.toString());

						var c = grid.f_points.add(grid.controls, "variable", lst).listen();

						grid.id_controls.push([grid.f_points, c]);

						c.onFinishChange(function(value)
						{
							grid.points_variable = value;
						});

						grid.controls["point size"] = 0.25;

						var c = grid.f_points.add(grid.controls, "point size", 0, 0.5).step(0.05)
						
						grid.id_controls.push([grid.f_points, c]);

						c.onFinishChange(function(value)
						{
							grid.points_size = value;
							if ( grid.points_variable == "" && value != 0 && 
								loader.grid[0][0][0][0].length > 3)
							{
								grid.controls["variable"] = "1";
								grid.points_variable = "1";
							}
						});

						grid.controls["internal"] = false;

						var c = grid.f_points.add(grid.controls, "internal").listen();

						grid.id_controls.push([grid.f_points, c]);

						c.onFinishChange(function(value)
						{
							grid.points_options = [value];
						});	

						grid.controls["set palette"] = function() {
							palette_dialog_text.text = legend.colors.join("\n");
							palette_dialog.open();
						};

						var c = grid.f_points.add(grid.controls, "set palette");

						grid.id_controls.push([grid.f_points, c]);
					}

					// filter

					grid.filter_block = -1
					grid.filter_controls_changed = 0

					grid.s_controls["internal"] = true;
					
					grid.s_controls["Default Style"] = true;
					grid.style_default = true;

					grid.controls["parameter"] = "";

					var lst = [""];

					for ( var i = 1; i <= loader.grid.length; i++ ) 
						lst.push("Block " + i.toString());

					for ( var i = 1; i <= loader.types.length; i++ ) 
						lst.push("Scalar " + i.toString());

					lst.push("List of cells");

					var c = grid.f_filter.add(grid.controls, "parameter", lst).listen();

					grid.id_controls.push([grid.f_filter, c]);

					c.onFinishChange(function(value)
					{
						grid.filter_scalar = -1;
						grid.filter_list = [];

						var v = value.split(' ');

						if (value != "" && v[0] == "Block")
						{	
							value = v[1];

							var l;

							l = loader.grid[value - 1][0][0].length;
							grid.filter_detail_i = [0, l - 1, 1];
							l = loader.grid[value - 1][0].length;
							grid.filter_detail_j = [0, l - 1, 1];
							l = loader.grid[value - 1].length;
							grid.filter_detail_k = [l - 2, l - 1, 1];

							if ((4 & grid.filter_controls_changed) == 4)
								grid.s_controls["lines i"] = true;

							if ((8 & grid.filter_controls_changed) == 8)
								grid.s_controls["lines j"] = true;

							if ((16 & grid.filter_controls_changed) == 16)
								grid.s_controls["lines k"] = true;

							filter_upd(value);								
						} 
						else
						{
							grid.filter_block = -1;

							while(grid.items_filter.length > 0)
							{
								var c = grid.items_filter.pop();
								grid.f_filter.remove(c);
							}

							grid.f_filter.removeFolder("Lines Style");
							grid.f_filter.removeFolder("Faces Style");

							if(grid.filter_controls_changed != 0)
							{
								if ((1 & grid.filter_controls_changed) == 1)
									grid.s_controls["internal"] = true;
								
								if ((2 & grid.filter_controls_changed) == 2)
								{
									grid.s_controls["Default Style"] = true;
									grid.style_default = true;

									grid.f_blocks.removeFolder("Lines Style");
									grid.f_blocks.removeFolder("Faces Style");
								}

								if ((4 & grid.filter_controls_changed) == 4)
									grid.s_controls["lines i"] = true;

								if ((8 & grid.filter_controls_changed) == 8)
									grid.s_controls["lines j"] = true;

								if ((16 & grid.filter_controls_changed) == 16)
									grid.s_controls["lines k"] = true;

								grid.filter_controls_changed = 0;
								
								grid.state_l_directions = 
									(grid.state_l_directions != 0)? 0: 1;
							}

							if (v[0] == "Scalar") 
							{
								value = parseInt(v[1]);

								var m = (loader.min[value + 2] + loader.max[value + 2]) / 2;
								
								if (!!loader.types[value - 1]) 
									m = Math.ceil(m);

								grid.filter_scalar_range = [
									Math.min(loader.max[value + 2], m),
									loader.max[value + 2]];

								filter_scalar_upd(value);
							} else if (v[0] != "") {
								filter_list_upd();
							}
						} 
					});

					function keypress_event(e) 
					{
						if (document.activeElement.type === "text" || 
							document.activeElement.type === "textarea") return;

						var ch = String.fromCharCode(e.keyCode);

						if (ch != 'k' && ch != 'K' && ch != 'j' && ch != 'J' &&
							ch != 'i' && ch != 'I' && ch != 'b' && ch != 'B' &&
							ch != 'л' && ch != 'Л' && ch != 'о' && ch != 'О' &&
							ch != 'ш' && ch != 'Ш' && ch != 'и' && ch != 'И')
							return;

						if (grid.filter_block < 0)
						{
							grid.controls["parameter"] = "Block 1";

							grid.filter_detail_i = [0, 1, 1];
							grid.filter_detail_j = [0, 1, 1];
							grid.filter_detail_k = [0, 1, 1];
							grid.filter_block = 0;

							filter_upd("1");
						}
						else 
						{
							var b = grid.filter_block;

							var k = grid.filter_detail_k[0];
							var j = grid.filter_detail_j[0];
							var i = grid.filter_detail_i[0];

							switch(ch)
							{
								case 'k':
								case 'л': 
									if ( k < loader.grid[b].length - 2 ) k++; 
									else k = loader.grid[b].length - 2; 
									break;
								case 'K':
								case 'Л':
									if (k > 1) k--; else k = 1; 
									break;
								case 'j': 
								case 'о': 
									if ( j < loader.grid[b][0].length - 2 ) j++; 
									else j = loader.grid[b][0].length - 2; 
									break;
								case 'J':
								case 'О': 
									if (j > 1) j--; else j = 1; 
									break;
								case 'i': 
								case 'ш': 
									if ( i < loader.grid[b][0][0].length - 2 ) i++;
									else i = loader.grid[b][0][0].length - 2;
									break;
								case 'I':
								case 'Ш': 
									if (i > 1) i--; else i = 1; 
									break;
								case 'b':
								case 'и':
									if( b < loader.grid.length - 1 ) b++; else b = 0;
									if (k > loader.grid[b].length - 2 ) 
										k = loader.grid[b].length - 2;
									if (j > loader.grid[b][0].length - 2 ) 
										j = loader.grid[b][0].length - 2;
									if (i > loader.grid[b][0][0].length - 2 ) 
										i = loader.grid[b][0][0].length - 2;
									break;
								case 'B':
								case 'И':
									if(b > 1) b--; else b = loader.grid.length - 1;
									if (k > loader.grid[b].length - 2 ) 
										k = loader.grid[b].length - 2;
									if (j > loader.grid[b][0].length - 2 ) 
										j = loader.grid[b][0].length - 2;
									if (i > loader.grid[b][0][0].length - 2 ) 
										i = loader.grid[b][0][0].length - 2;
									break;
							}

							grid.filter_detail_k = [k, k + 1, 1];
							grid.filter_detail_j = [j, j + 1, 1];
							grid.filter_detail_i = [i, i + 1, 1];

							grid.filter_block = b;

							grid.controls["parameter"] = "Block " + (b + 1).toString();

							filter_upd((b + 1).toString());
						}
					}
					
					window.addEventListener( "keypress", keypress_event, false );
				}

				data_counter ++;
			}

			GridLines
			{
				visible: block.option_visible

				data: loader.grid[ block.z ]
				scale_coeff: loader.scale_coeff

				detail: block.option_detail

				filter: block.z != grid.filter_block ? []: 
					[ grid.filter_detail_k,
					  grid.filter_detail_j, 
					  grid.filter_detail_i ]

				directions: grid.style_default ? [] : grid.l_directions
				colors: grid.style_default ? [] : grid.l_colors
				options: grid.style_default ? [] : grid.l_options

				filter_directions: grid.style_filter_default ? [] : 
					grid.l_filter_directions
				filter_colors: grid.style_filter_default ? [] : 
					grid.l_filter_colors
				filter_options: grid.style_filter_default ? [] : 
					grid.l_filter_options

				filter_scalar: (grid.filter_scalar != -1)? 
					[grid.filter_scalar, grid.filter_scalar_range]: []

				filter_list: (grid.filter_list.length > block.z)? 
					grid.filter_list[ block.z ] :[] 
			}

			GridFaces
			{
				visible: block.option_visible

				data: loader.grid[ block.z ]
				scale_coeff: loader.scale_coeff

				detail: block.option_detail

				filter: block.z != grid.filter_block ? []: 
					[ grid.filter_detail_k,
					  grid.filter_detail_j, 
					  grid.filter_detail_i ]

				directions: grid.style_default ? [] : grid.f_directions
				colors: grid.f_colors
				options:  grid.f_options

				filter_directions: grid.style_filter_default ? [] : 
					grid.f_filter_directions
				filter_colors: grid.f_filter_colors
				filter_options: grid.f_filter_options

				filter_scalar: (grid.filter_scalar != -1)? 
					[grid.filter_scalar, grid.filter_scalar_range]: []

				filter_list: (grid.filter_list.length > block.z)? 
					grid.filter_list[ block.z ] :[] 
			}

			GridPoints
			{
				id: gridpoints
				visible: block.option_visible
				data: loader.grid[ block.z ]
				scale_coeff: loader.scale_coeff
				variable: grid.points_variable
				min: loader.min
				max: loader.max
				index: block.z
				colors: legend.colors
				radius: grid.points_size
				options: grid.points_options
				types: loader.types
			}
		}
	}

	SceneMouseEvents {
		
		onDoubleClicked: {			
			
			var min;
			var min_r;
			var min_ind;

			for (var i = 0; i < grid['$items'].length ; i++) {

				var gridpoints = grid['$items'][i].children[2];

				var r = gridpoints.intersect( sceneMouse );

				if (!!r && grid['$items'][i].option_visible)
				{
					if (!min || r.distance < min)
					{
						min = r.distance;
						min_r = r;
						min_ind = gridpoints.index;
					}
				}
			};

			if (!!min_r)
			{
				var nk, nj, ni, k, j, i;

				ni = loader.grid[ min_ind ][0][0].length;
				nj = loader.grid[ min_ind ][0].length;
				nk = loader.grid[ min_ind ].length;

				if (grid.points_options[0])
				{
					k = Math.floor(min_r.index / (ni * nj));
					j = Math.floor((min_r.index - k * ni * nj) / ni);
					i = min_r.index - k * ni * nj - j * ni;
				} else {
					var ind = -1;
					var f = false;

					for (var kt = 0; kt < nk; kt++)
					{	
						for (var jt = 0; jt < nj; jt++)
						{
							for (var it = 0; it < ni; it++)
							{
								if (kt == 0 || kt == nk - 1 ||
									jt == 0 || jt == nj - 1 ||
									it == 0 || it == ni - 1) 
									ind ++;

								if (ind == min_r.index)
								{
									k = kt; j = jt; i = it; 
									f = true;
								}

								if (f) break;
							}
							if (f) break;
						}
						if (f) break;
					}
				}

				tmp = loader.grid[ min_ind ][k][j][i];

				if (grid.point[0] != tmp[0] || grid.point[1] != tmp[1] || 
					grid.point[2] != tmp[2])
				{
					grid.point_size = grid.points_size * 2;
					grid.point = tmp;
					grid.point_ind = [min_ind, k, j, i];
				}
				else
				{
					grid.point_size = (grid.point_size == grid.points_size)?
						grid.points_size * 2: grid.points_size
				}
			}
		}
	}

	GridPoints
	{
		visible: (!!grid.point && grid.point.length > 3)
		data: (!!grid.point && grid.point.length > 3)? [[[ grid.point.slice() ]]]: []
		scale_coeff: loader.scale_coeff
		variable: grid.points_variable
		min: loader.min
		max: loader.max
		colors: legend.colors
		radius: grid.point_size
		types: loader.types
	}

	Column
	{
		property var tag: "left"

		Text
		{

			text: (grid.points_variable != "" && 
					parseInt(grid.points_variable) + 3 <= loader.grid[0][0][0][0].length && 
					!!grid.point && grid.point.length > 3 &&
					grid.point_size != grid.points_size)? msg(): ""
			
			function msg()
			{
				var m = '<br/><br/><span style="' + 
				'font-size: 120%; color: white; background-color: rgba(0, 0, 0, 0.7);">' + 
				"&nbsp;Selected: ";

				m += "block: " + (grid.point_ind[0] + 1).toString() + ";&nbsp;\n"; 

				if(grid.point_ind.length > 2)
				{
					m += "&nbsp;i: " + (grid.point_ind[3] + 1).toString() + "; j: " +
						(grid.point_ind[2] + 1).toString() + "; k: " + 
						(grid.point_ind[1] + 1).toString() + ";&nbsp;\n\n";
				}

				if(grid.point.length > 2)
				{
					m += "&nbsp;x = " + grid.point[0] + ";&nbsp;\n&nbsp;y = " +
						 grid.point[1] + ";&nbsp;\n&nbsp;z = " + grid.point[2] + ";&nbsp;\n\n";
				}

				for(var i = 3; i < grid.point.length; i++)
				{
					m += (parseInt(grid.points_variable) + 2 != i)? 
						"&nbsp;" + grid.point[i] + ";&nbsp;\n": 
						"&nbsp;[&nbsp;" + grid.point[i] + "&nbsp;];&nbsp;\n";
				}

				return m + "</span>";
			}
		}

		Text
		{
			text: (grid.points_variable != "" && 
					parseInt(grid.points_variable) + 3 <= loader.grid[0][0][0][0].length )? 
					"<br/><br/>Points:": ""
		}

		Column
		{

			Row
			{
				Item
				{
					id: legend

					height: 18
					width: 180

					property var htmlNode
					property var colors: get_colors(loader.types, grid.points_variable);

					function get_colors(types, variable)
					{
						if (types.length > 0 && variable!= "" && 
							!!types[parseInt(variable) - 1]) 
						{
							var values = Object.keys(types[parseInt(variable) - 1]);

							var coeff = Math.floor(values.length / 3);
							var offset = coeff - 1 - (values.length % coeff);	

							var step = 1 / (values.length + offset);

							var cols = [];
							var color = 0;

							if (values.length < 3) { step = 1 / 6; coeff = 1; offset = 0; }

							for (var i = 0; i < values.length; i++)
							{
								color = ((i * coeff) % (values.length + offset)) * step;

								if (color > 0.3 && color < 0.45){

									var cf = (i * coeff) % (values.length + offset);

									var v = ((cf % 2)? -1: 1) * 
										(cf / (values.length + offset)) * 0.3;
									
									cols.push("#" + new THREE.Color()
										.setHSL(color, 0.96 - color + v, 0.56 - v).getHex().toString(16));
								}
								else if (color > 0.65 && color < 0.7) {
									cols.push("#" + new THREE.Color()
										.setHSL(color, 0.96 - color / 3, 0.56).getHex().toString(16));
								}
								else
									cols.push("#" + new THREE.Color()
										.setHSL(color, 0.96, 0.56).getHex().toString(16));
							}

							return cols;
						}

						return ["#0022ff", "#00ddff", "#66ff33", "#ffff00", "#ffbb00", "#ff2200"];
					}
					
					property var scalar: (grid.points_variable == "" || 
						parseInt(grid.points_variable) + 3 <= loader.grid[0][0][0][0].length)? 
							grid.points_variable : ""

					property var range: (grid.points_variable != "" && 
						parseInt(grid.points_variable) + 3 <= loader.grid[0][0][0][0].length)? 
						[loader.min[parseInt(grid.points_variable) + 2], 
						loader.max[parseInt(grid.points_variable) + 2]]: 
						[0, 1]

					Component.onCompleted: {

						legend.dom.innerHTML = "<div>" + 
							"<canvas id='legend' style='position: relative'> </canvas>" + 
							"<svg style='position: relative'> </svg>" +
							"</div>";

						htmlNode = legend.dom.firstChild;
						htmlNode.style.display = "none";
					}

					function draw_gradient()
					{
						if (colors.length < 2) { 
							colors = get_colors(loader.types, grid.points_variable);
							return;
						}

						if(!!htmlNode)
						{
							var canvas = htmlNode.childNodes[0];

							width = 180;
							height = 18;

							canvas.width = width;
							canvas.height = height + 32;

							var svg = htmlNode.childNodes[1];
							svg.innerHTML = "";

							svg.setAttribute('style', 
								'width: ' + width + '; height:' + (height + 32).toString());

							htmlNode.style.display = (scalar == "")? "none": "block";

							var ctx = canvas.getContext("2d");

							ctx.rect(0, 0, canvas.width, canvas.height);
							ctx.clearRect(0, 0, canvas.width, canvas.height);

							if (scalar != "" && loader.types.length > 0 && 
							!!loader.types[parseInt(scalar) - 1])
							{
								// canvas

								keys = Object.keys(loader.types[scalar - 1]);

								width = 100;
								height = 32 * keys.length;

								canvas.width = width;
								canvas.height = height;

								ctx.fillStyle = "#FFFFFF";
								ctx.fillRect(0, 0, width, height);

								for(var i = 0; i < keys.length; i++)
								{
									ctx.fillStyle = colors[i];
									ctx.fillRect(3, 32 * i + 5, 23, 20);

									ctx.fillStyle = "#000000";
									ctx.font = "14pt Arial";

									ctx.textAlign = "left";
									ctx.fillText(keys[i].toString(), 33, 32 * i + 22);
								}

								// svg

								svg.setAttribute('style', 
									'width: ' + width + '; height:' + height);

								var svgns = "http://www.w3.org/2000/svg";

								for(var i = 0; i < keys.length; i++)
								{
									var rect = document.createElementNS(svgns, 'rect');
									rect.setAttributeNS(null, 'x', 3);
									rect.setAttributeNS(null, 'y', 32 * i + 5);
									rect.setAttributeNS(null, 'width', 23);
									rect.setAttributeNS(null, 'height', 20);
									rect.setAttributeNS(null, 'fill', colors[i]);

									svg.appendChild(rect);

									var text = document.createElementNS(svgns, 'text');
								
									text.setAttributeNS(null, 'x', 33);
									text.setAttributeNS(null, 'y', 32 * i + 22);
									text.setAttributeNS(null, 'fill', '#000000');
									text.setAttributeNS(null, 'text-anchor', 'start');
									text.appendChild(document.createTextNode(
										keys[i].toString()));

									svg.appendChild(text);
								}

							}
							else if (scalar != "") 
							{
								// canvas

								ctx.fillStyle = "#FFFFFF";
								ctx.fillRect(0, 0, canvas.width, canvas.height);

								var gradient = ctx.createLinearGradient(0, 0, width, 0);

								for(var i = 0; i < colors.length; i++)
									gradient.addColorStop(i / (colors.length - 1), colors[i]);

								ctx.fillStyle = gradient;
								ctx.fillRect(3, 3, width - 6, height + 2);

								ctx.fillStyle = "#000000";
								ctx.font = "14pt Arial";

								ctx.textAlign = "left";
								ctx.fillText(range[0].toFixed(5).toString(), 
									0, height + 22);
								ctx.textAlign = "right";
								ctx.fillText(range[1].toFixed(5).toString(), 
									width, height + 22);

								// svg

								var svgns = "http://www.w3.org/2000/svg";

								var rect = document.createElementNS(svgns, 'rect');
								rect.setAttributeNS(null, 'x', 3);
								rect.setAttributeNS(null, 'y', 3);
								rect.setAttributeNS(null, 'width', width - 6);
								rect.setAttributeNS(null, 'height', height + 2);
								
								var grad = document.createElementNS(svgns, 'linearGradient');
								grad.setAttributeNS(null, 'id', 'grad');

								for(var i = 0; i < colors.length; i++)
								{
									var stop = document.createElementNS(svgns, 'stop');
									stop.setAttributeNS(null, 'offset', i / (colors.length - 1));
									stop.setAttributeNS(null, 'stop-color', colors[i]);
									grad.appendChild(stop);
								}

								var defs = document.createElementNS(svgns, 'defs')
								defs.appendChild(grad);

								svg.insertBefore(defs, svg.firstChild);
								rect.setAttributeNS(null, 'fill', 'url(#grad)');
								svg.appendChild(rect);

								var text;

								text = document.createElementNS(svgns, 'text');
								
								text.setAttributeNS(null, 'x', 0);
								text.setAttributeNS(null, 'y', height + 22);
								text.setAttributeNS(null, 'fill', '#000000');
								text.setAttributeNS(null, 'text-anchor', 'start');
								text.appendChild(document.createTextNode(
									range[0].toFixed(5).toString()));

								svg.appendChild(text);

								text = document.createElementNS(svgns, 'text');
								
								text.setAttributeNS(null, 'x', width);
								text.setAttributeNS(null, 'y', height + 22);
								text.setAttributeNS(null, 'fill', '#000000');
								text.setAttributeNS(null, 'text-anchor', 'end');
								text.appendChild(document.createTextNode(
									range[1].toFixed(5).toString()));

								svg.appendChild(text);
							}

							svg.style.display = "none";
						}
					}

					onRangeChanged: {
						legend.colors = get_colors(loader.types, grid.points_variable); 
					}

					onScalarChanged: draw_gradient();
					onColorsChanged: draw_gradient();
				}
			}
		}
	}

	SimpleDialog 
	{
		id: palette_dialog
		title: "Palette settings"
		width: palette_dialog_column.width + 30
		height: palette_dialog_column.height + 50

		Column 
		{
			id: palette_dialog_column
			width: 500
			spacing: 8
			x: 10
			y: 8

			Text 
			{
				text: "Enter colors:";
			}

			TextEdit
			{
				id: palette_dialog_text
				width: parent.width
				height: 300
				text: ""
			}

			Button
			{
				text: "Ok"
				width: 150
				onClicked: { 
					var prs = palette_dialog_text.text.replace(
						/[^\s\d#ABCDEFabcdef]/g, ' ').split(/\s+/);

					var lst = [];

					for (var i = 0; i < prs.length; i++) {
						if (prs[i].substring(0, 1) != "#") prs[i] = "#" + prs[i];
						
						var numb = parseInt(prs[i].substring(1), 16);
						if (numb >= 0 && numb <= 0xffffff) lst.push(prs[i]);
					}

					legend.colors = lst;
					palette_dialog.close();
				}
			}
		}
	}

	SimpleDialog 
	{
		id: list_dialog
		title: "List of cells"
		width: list_dialog_column.width + 30
		height: list_dialog_column.height + 50
		
		Column 
		{
			id: list_dialog_column
			width: 800
			height: 600
			spacing: 8
			x: 10
			y: 8
			
			Text 
			{
				text: "<b>Enter cells:</b> <i>block i j k</i>";
			}

			TextEdit
			{
				id: list_dialog_text
				width: parent.width
				height: parent.height - 100
				text: ""
			}

			Button
			{
				text: "Ok"
				width: 150
				onClicked: { 
					var prs = list_dialog_text.text.replace(
						/[^\s\d]/g, ' ').split(/\s+/);

					for (var i = 0; i < prs.length; i ++)
						prs[i] = parseInt(prs[i]) - 1;
					for (var i = 0; i < prs.length; i ++)
						if (!(prs[i] >= 0)) prs.splice(i, 1);

					var lst = [];

					for(var i = 0; i < loader.status; i++)
						lst.push([]);

					var ind = 0;
					
					for (var i = 0; i < prs.length; i += 4) {
						if(prs[i] >= 0 && prs[i] < lst.length) {
							lst[prs[i]].push([
								prs[i + 1], prs[i + 2], prs[i + 3] ]);
						}
					}

					grid.filter_list = lst;
					
					list_dialog.close();
				}
			}
		}
	}

	SimpleDialog 
	{
		id: about_dialog
		title: "About"
		width: about_dialog_column.width + 30
		height: about_dialog_column.height + 50

		Column 
		{
			id: about_dialog_column
			width: 550
			height: 350
			spacing: 8
			x: 10
			y: 8

			Text 
			{
				text: "<pre>" + 
					"Data format: <b>Tecplot ASCII</b>\n\n" + 
					"Navigation: \n" +
					"\t<b>left click</b> - rotate\n" +
					"\t<b>scroll</b> - change the distance to the center\n" +
					"\t<b>right click</b> - shift the center\n" +
					"Cells jump: \n"+
					"\t<b>b</b>, <b>B</b>, <b>i</b>, <b>I</b>, <b>j</b>, <b>J</b>, " +
					"<b>k</b>, <b>K</b>\n" +
					"Select point: <b>double click</b>\n" +
					"Hide menu: <b>Ctrl + Q</b>, <b>H</b>\n\n" +
					"Repository: <a href=\"https://github.com/olga3n/viewlang_setki\">" + 
					"github</a>\n" +
					"</pre>";
			}
		}
	}
}
