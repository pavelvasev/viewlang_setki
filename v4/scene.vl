import "obj"

Scene 
{
	id: thescene
	text: ""
	
	property var script_gui_flag: false
	property var script_grid_flag: false
	property var script_lib_flag_1: false
	property var script_lib_flag_2: false
	property var script_lib_flag_3: false

	property var q: script_init()

	function script_init()
	{
		if ( !script_gui_flag )
			la_require( 
				$basePath + "lib/dat.gui/build/dat.gui.min.js",
				function() { 
					
					// add remove folder function
					dat.GUI.prototype.removeFolder = function(name) {
						var folder = this.__folders[name];
						if (!folder) return;
						folder.close();
						this.__ul.removeChild(folder.domElement.parentNode);
						delete this.__folders[name];
						this.onResize();
					}

					script_gui_flag = true; 
				});

		if( !script_lib_flag_1 )
			la_require(
				$basePath + 
				"lib/three.js/examples/js/renderers/Projector.js",
				function() { script_lib_flag_1 = true; });

		if( !script_lib_flag_2 )
			la_require(
				$basePath + 
				"lib/three.js/examples/js/renderers/SVGRenderer.js",
				function() { script_lib_flag_2 = true; });

		if( !script_lib_flag_3 )
			la_require(
				$basePath + 
				"lib/FileSaver.js/FileSaver.min.js",
				function() { script_lib_flag_3 = true; });

		if ( !script_grid_flag )
			la_require( 
				$basePath + "js/grid.js", 
				function() { script_grid_flag = true; });

		renderer.setClearColor( 0xd8dde2, 1 );
	}

	FileParam
	{
		id: inputFile
		text: "Grid file:"
		file: Qt.resolvedUrl( "../ris5.dat" )
		multiple: true
	}

	Repeater {
		id: loaders_f1
		model: inputFile.files.length
		//onModelChanged: console.log("model=",model);
		Load {
			id: loader1
			file: inputFile.files[ index ]
		}
	}

	LoadJoiner {
	  id: loader
	  //loaders: [loader1]
	  loaders: loaders_f1['$items']
	  onLoadersChanged: console.log("loaders=",loaders);

		onGridChanged: {
		  console.log("LoadJoner onGridChanged => grid.length=",grid.length);
		  //debugger;
			data_counter = 0;
			data_controls = {};
		}
	}

	Axis { }

	Repeater
	{
		id: grid
		model: loader.grid.length

		property var gui
		property var q: init_controls()

		property var f_blocks
		property var f_visible
		property var f_detail
		property var f_filter
		property var f_points
		property var f_export

		property var controls: {}
		property var d_controls: {}
		property var s_controls: {}
		property var fs_controls: {}
		property var id_controls: []

		property var filter_block: -1
		property var filter_detail_i: [0, 1, 1]
		property var filter_detail_j: [0, 1, 1]
		property var filter_detail_k: [0, 1, 1]
		property var items_filter: []

		property var style_default: true
		property var style_filter_default: true

		property var l_directions: [true, true, true, true]
		property var l_colors: 
			["#ffffff", "#ffffff", "#ffffff", "#000000"]
		property var l_options: [false, false] //[false, true]

		property var l_filter_directions: [true, true, true, true]
		property var l_filter_colors: 
			["#000000", "#000000", "#000000", "#0000ff"]
		property var l_filter_options: [false, true]

		property var f_directions: [false, false, false]
		property var f_colors: ["#00ffff", "#ff00ff", "#ffff00"]
		property var f_options: [0.2]

		property var f_filter_directions: [true, true, true]
		property var f_filter_colors: ["#00ff88", "#8800ff", "#ff8800"]
		property var f_filter_options: [0.2]

		property var state_l_materials: 0
		property var state_l_directions: 0

		property var state_f_materials: 0
		property var state_f_directions: 0

		property var filter_controls_changed: 0

		property var points_variable: ""
		property var points_size: 0.25
		property var point: []
		property var point_size: 0.25
		property var point_ind: []

		property var points_options: [false]

		property var cubes: []

		property var counter: 0

		property var filter_scalar: -1
		property var filter_scalar_range: [0, 0]

		property var export_buttons: []

		onState_l_materialsChanged: {		

			l_colors = [
				s_controls["lines i color"], 
				s_controls["lines j color"], 
				s_controls["lines k color"], 
				s_controls["border color"]];
			l_options = [
				s_controls["lines dashed"], 
				s_controls["border bold"]];
			
			l_filter_colors = [
				fs_controls["lines i color"], 
				fs_controls["lines j color"], 
				fs_controls["lines k color"], 
				fs_controls["border color"]]
			l_filter_options = [
				fs_controls["lines dashed"], 
				fs_controls["border bold"]];
		}

		onState_l_directionsChanged: {

			if (style_default != s_controls["Default Style"])
				style_default = s_controls["Default Style"];
			if (style_filter_default != fs_controls["Default Style"])
				style_filter_default = fs_controls["Default Style"];
			
			l_directions = [
				s_controls["lines i"], 
				s_controls["lines j"],
				s_controls["lines k"],
				s_controls["internal"]];

			l_filter_directions = [
				fs_controls["lines i"], 
				fs_controls["lines j"],
				fs_controls["lines k"],
				fs_controls["internal"]];
		}

		onState_f_materialsChanged: {
			
			if (style_default != s_controls["Default Style"])
				style_default = s_controls["Default Style"];
			if (style_filter_default != fs_controls["Default Style"])
				style_filter_default = fs_controls["Default Style"];		

			f_colors = [
				s_controls["faces ij color"], 
				s_controls["faces ik color"], 
				s_controls["faces jk color"] ];
			f_options = [
				s_controls["faces opacity"]];

			f_filter_colors = [
				fs_controls["faces ij color"], 
				fs_controls["faces ik color"], 
				fs_controls["faces jk color"] ];
			f_filter_options = [
				fs_controls["faces opacity"]];
		}

		onState_f_directionsChanged: {
			f_directions = [
				s_controls["faces ij"], 
				s_controls["faces ik"], 
				s_controls["faces jk"]];

			f_filter_directions = [
				fs_controls["faces ij"], 
				fs_controls["faces ik"], 
				fs_controls["faces jk"]];
		}

		onPoints_variableChanged: {
			for (var i = 0; i < export_buttons.length; i ++)
				f_export.remove(export_buttons[i]);

			export_buttons = [];

			if (points_variable != "") {
				var c = f_export.add(grid.controls, "Legend *.png");
				export_buttons.push(c);
				c = f_export.add(grid.controls, "Legend *.svg");
				export_buttons.push(c);
			}
		}

		function save_file(type, obj, name)
		{
			if (type == "png")
			{
				var canvas = obj;

				try {
					var isFileSaverSupported = !!new Blob;
							
					var ctx = canvas.getContext("2d");

					var binary = atob(
						canvas.toDataURL("image/png").replace(
							/^data:image\/(png|jpg);base64,/, "")
						);

					var raw_buffer = new ArrayBuffer(binary.length);
					var integers = new Uint8Array(raw_buffer);
								
					for (var i = 0; i < binary.length; i++)
						integers[i] = binary.charCodeAt(i);

					binary = raw_buffer;

					var blob = new Blob([binary], {type: 'image/png'});
							
					saveAs(blob, name + ".png");

				} catch (e) {
					window.open(canvas.toDataURL());
				}
			} 
			else if (type == "svg")
			{
				var svg = obj;

				var serializer = new XMLSerializer();
				var svg_blob = new Blob([serializer.serializeToString(svg)], 
					{'type': "image/svg+xml"});

				try {
					var isFileSaverSupported = !!new Blob;
					saveAs(svg_blob, name + ".svg");
				} catch (e) {
					var url = URL.createObjectURL(svg_blob);
					window.open(url);
				}
			}
		}

		function init_controls()
		{
			if ( script_gui_flag && script_lib_flag_1 && script_lib_flag_2 )
			{
				gui = new dat.GUI( { width: 350 } );

				f_blocks = gui.addFolder('Blocks');

				f_visible = f_blocks.addFolder("Visible");
				f_detail = f_blocks.addFolder("Detail");

				s_controls["lines i"] = true;
				s_controls["lines j"] = true;
				s_controls["lines k"] = true;
				s_controls["lines i color"] = "#ffffff";
				s_controls["lines j color"] = '#ffffff';
				s_controls["lines k color"] = '#ffffff';
				s_controls["lines dashed"] = false;
				s_controls["border color"] = '#000000';
				s_controls["border bold"] = true;
				s_controls["internal"] = true;
				
				s_controls["faces ij"] = false;
				s_controls["faces ik"] = false;
				s_controls["faces jk"] = false;
				s_controls["faces ij color"] = '#00ffff';
				s_controls["faces ik color"] = '#ff00ff';
				s_controls["faces jk color"] = '#ffff00';
				s_controls["faces opacity"] = 0.2;

				s_controls["Default Style"] = true;

				var c = f_blocks.add(s_controls, "Default Style").listen();

				c.onFinishChange(function(value)
				{ 
					if ( value ) 
					{
						f_blocks.removeFolder("Lines Style");
						f_blocks.removeFolder("Faces Style");
					} 
					else 
					{
						grid.add_style_folders();
						
						grid.state_l_directions = 
							(grid.state_l_directions != 0)? 0: 1;
						grid.state_f_directions = 
							(grid.state_f_directions != 0)? 0: 1;
					}
					grid.style_default = value;
				});	

				fs_controls["lines i"] = true;
				fs_controls["lines j"] = true;
				fs_controls["lines k"] = true;
				fs_controls["lines i color"] = "#000000";
				fs_controls["lines j color"] = '#000000';
				fs_controls["lines k color"] = '#000000';
				fs_controls["lines dashed"] = false;
				fs_controls["border color"] = '#0000ff';
				fs_controls["border bold"] = true;
				fs_controls["internal"] = true;
				
				fs_controls["faces ij"] = true;
				fs_controls["faces ik"] = true;
				fs_controls["faces jk"] = true;
				fs_controls["faces ij color"] = '#00ff88';
				fs_controls["faces ik color"] = '#8800ff';
				fs_controls["faces jk color"] = '#ff8800';
				fs_controls["faces opacity"] = 0.2;

				fs_controls["Default Style"] = true;

				f_points = gui.addFolder('Points');
				f_filter = gui.addFolder('Filter');
				f_export = gui.addFolder('Export');

				grid.controls["*.png"] = function() {
					save_file("png", $("body").children("canvas")[0], "grid");
				};

				grid.controls["*.svg [slow]"] = function() {
					renderer_SVG = new THREE.SVGRenderer();

					renderer_SVG.setSize(window.innerWidth, window.innerHeight);

					var cubes = [];

					for ( var i = 0; i < grid['$items'].length; i++ )
					{
						if(grid['$items'][i].children[2]['$properties']['visible'].val
							&& !! grid['$items'][i].children[2]['$properties']['cubes'].val )
						{
							cubes.push(
								grid['$items'][i].children[2]['$properties']['cubes'].val);
						}
					}

					if(cubes.length > 0)
					{
						var svgscene = jQuery.extend(true, {}, scene);

						for (var i = 0; i < cubes.length; i++)
							svgscene.add(cubes[i]);

						renderer_SVG.render(svgscene, camera);
						svgscene = undefined;
					}
					else
					{
						renderer_SVG.render(scene, camera);
					}

					document.body.appendChild( renderer_SVG.domElement );
					save_file("svg", $("body").children("svg")[0], "grid");
					document.body.removeChild( renderer_SVG.domElement );
				};

				grid.controls["Legend *.png"] = function() {
					if (grid.points_variable != "") 
						save_file("png", legend.dom.firstChild.childNodes[0], "legend");
				};

				grid.controls["Legend *.svg"] = function() {
					if (grid.points_variable != "") 
						save_file("svg", legend.dom.firstChild.childNodes[1], "legend");
				};

				f_export.add(grid.controls, "*.png");
				f_export.add(grid.controls, "*.svg [slow]");
			}
		}

		function add_style_controls(f_lines, f_faces, controls)
		{			
			var change_l_m = function(value) { 
				grid.state_l_materials =
					(grid.state_l_materials != 0)? 0: 1; }
			var change_l_d = function(value) {
				grid.state_l_directions = 
					(grid.state_l_directions != 0)? 0: 1; }

			var change_f_m = function(value) { 
				grid.state_f_materials =
					(grid.state_f_materials != 0)? 0: 1; }
			var change_f_d = function(value) {
				grid.state_f_directions = 
					(grid.state_f_directions != 0)? 0: 1; }

			f_lines.add(controls, "lines i").onFinishChange(change_l_d).listen(); 
			f_lines.add(controls, "lines j").onFinishChange(change_l_d).listen(); 
			f_lines.add(controls, "lines k").onFinishChange(change_l_d).listen(); 
			f_lines.addColor(controls, "lines i color").onChange(change_l_m); 
			f_lines.addColor(controls, "lines j color").onChange(change_l_m); 
			f_lines.addColor(controls, "lines k color").onChange(change_l_m);
			f_lines.add(controls, "internal").onFinishChange(change_l_d).listen();
			f_lines.add(controls, "lines dashed").onFinishChange(change_l_m); 
			f_lines.addColor(controls, "border color").onChange(change_l_m); 
			//f_lines.add(controls, "border bold").onFinishChange(change_l_m); 
							
			f_faces.add(controls, "faces ij").onFinishChange(change_f_d).listen();
			f_faces.add(controls, "faces ik").onFinishChange(change_f_d).listen();
			f_faces.add(controls, "faces jk").onFinishChange(change_f_d).listen();
			f_faces.addColor(controls, "faces ij color").onChange(change_f_m);
			f_faces.addColor(controls, "faces ik color").onChange(change_f_m);
			f_faces.addColor(controls, "faces jk color").onChange(change_f_m);
			f_faces.add(controls, "faces opacity", 0, 1).step(0.05)
				.onFinishChange(change_f_m);
		}

		function add_style_folders()
		{
			f_blocks.removeFolder("Lines Style");
			f_blocks.removeFolder("Faces Style");

			var f_lines = f_blocks.addFolder("Lines Style");
			var f_faces = f_blocks.addFolder("Faces Style");

			add_style_controls(f_lines, f_faces, s_controls);
		}

		function add_fstyle_folders()
		{
			var f_lines = f_filter.addFolder("Lines Style");
			var f_faces = f_filter.addFolder("Faces Style");

			add_style_controls(f_lines, f_faces, fs_controls);
		}

		Item
		{
			id: block
			property var z: index

			property var q: add_controls()

			property var option_visible: true
			property var option_detail: [
					Math.floor(loader.grid[ index ].length / 25) + 1,
					Math.floor(loader.grid[ index ][0].length / 25) + 1,
					Math.floor(loader.grid[ index ][0][0].length / 25) + 1
				]

			function filter_upd(value)
			{
				grid.fs_controls["faces ij"] = true;
				grid.fs_controls["faces ik"] = true;
				grid.fs_controls["faces jk"] = true;

				if (grid.s_controls["internal"])
				{
					grid.filter_controls_changed |= 1;
					grid.s_controls["internal"] = false;
				}
							
				if (grid.s_controls["Default Style"])
				{
					grid.filter_controls_changed |= 2;
					grid.s_controls["Default Style"] = false;
					grid.style_default = false;

					grid.add_style_folders();
				}
							
				grid.state_l_directions = 
					(grid.state_l_directions != 0)? 0: 1;

				grid.state_f_directions = 
					(grid.state_f_directions != 0)? 0: 1;

				grid.filter_block = value - 1;

				while(grid.items_filter.length > 0)
				{
					var c = grid.items_filter.pop();
					grid.f_filter.remove(c);
				}

				grid.f_filter.removeFolder("Lines Style");
				grid.f_filter.removeFolder("Faces Style");

				var c, t, l; 

				l = loader.grid[value - 1][0][0].length;
				t = "i (" + l.toString() + ")";
				grid.controls[t] = 
					"from " + (grid.filter_detail_i[0] + 1).toString() + 
					" to " + (grid.filter_detail_i[1] + 1).toString() + 
					" by " + (grid.filter_detail_i[2]).toString();
				c = grid.f_filter.add(grid.controls, t).listen();
				grid.items_filter.push(c);

				c.onFinishChange(function(value)
				{ 
					var numb = value.match(/\d+/g);
						
					if(!!numb) {
						var tmp = [1, 1, 1];
						if (numb.length > 0) tmp[0] = parseInt(numb[0]) - 1;
						if (numb.length > 1) tmp[1] = parseInt(numb[1]) - 1;
							else tmp[1] = tmp[0] + 1;
						if (numb.length > 2) tmp[2] = parseInt(numb[2]) - 1;
						grid.filter_detail_i = [tmp[0], tmp[1], tmp[2]];
					} else {
						l = loader.grid[
							grid.filter_block][0][0].length;
						grid.filter_detail_i = [0, l - 1, 1];

						t = "i (" + l.toString() + ")";
						grid.controls[t] = 
							"from 1 to " + l.toString() + " by 1";
					}
				});

				l = loader.grid[value - 1][0].length;
				t = "j (" + l.toString() + ")";
				grid.controls[t] = 
					"from " + (grid.filter_detail_j[0] + 1).toString() + 
					" to " + (grid.filter_detail_j[1] + 1).toString() + 
					" by " + (grid.filter_detail_j[2]).toString();
				c = grid.f_filter.add(grid.controls, t).listen();
				grid.items_filter.push(c);

				c.onFinishChange(function(value)
				{ 
					var numb = value.match(/\d+/g);
				
					if(!!numb) {
						var tmp = [1, 1, 1];
						if (numb.length > 0) tmp[0] = parseInt(numb[0]) - 1;
						if (numb.length > 1) tmp[1] = parseInt(numb[1]) - 1;
							else tmp[1] = tmp[0] + 1;
						if (numb.length > 2) tmp[2] = parseInt(numb[2]) - 1;
						grid.filter_detail_j = [tmp[0], tmp[1], tmp[2]];
					} else {
						l = loader.grid[grid.filter_block][0].length;
						grid.filter_detail_j = [0, l - 1, 1];

						t = "j (" + l.toString() + ")";
						grid.controls[t] = 
							"from 1 to " + l.toString() + " by 1";
					}
				});

				l = loader.grid[value - 1].length;
				t = "k (" + l.toString() + ")";
				grid.controls[t] = 
					"from " + (grid.filter_detail_k[0] + 1).toString() + 
					" to " + (grid.filter_detail_k[1] + 1).toString() + 
					" by " + (grid.filter_detail_k[2]).toString();
				c = grid.f_filter.add(grid.controls, t).listen();
				grid.items_filter.push(c);

				c.onFinishChange(function(value)
				{ 
					var numb = value.match(/\d+/g);
				
					if(!!numb) {
						var tmp = [1, 1, 1];
						if (numb.length > 0) tmp[0] = parseInt(numb[0]) - 1;
						if (numb.length > 1) tmp[1] = parseInt(numb[1]) - 1;
							else tmp[1] = tmp[0] + 1;
						if (numb.length > 2) tmp[2] = parseInt(numb[2]) - 1;
						grid.filter_detail_k = [tmp[0], tmp[1], tmp[2]];
					} else {
						l = loader.grid[grid.filter_block].length;
						grid.filter_detail_k = [0, l - 1, 1];

						t = "k (" + l.toString() + ")";
						grid.controls[t] = "from 1 to " + 
							l.toString() + " by 1";
					}
				});

				c = grid.f_filter.add(grid.fs_controls, "Default Style");

				if ( !grid.style_filter_default )
					grid.add_fstyle_folders();

				c.onFinishChange(function(value)
				{ 
					if ( value ) 
					{
						grid.f_filter.removeFolder("Lines Style");
						grid.f_filter.removeFolder("Faces Style");
					}
					else
					{
						grid.add_fstyle_folders();
						grid.state_l_directions = 
							(grid.state_l_directions != 0)? 0: 1;
						grid.state_f_directions = 
							(grid.state_f_directions != 0)? 0: 1;
					}

					grid.style_filter_default = value;
				});

				grid.items_filter.push(c);
			}

			function filter_scalar_upd(value)
			{
				if (grid.s_controls["lines i"])
				{
					grid.filter_controls_changed |= 4;
					grid.s_controls["lines i"] = false;
				}

				if (grid.s_controls["lines j"])
				{
					grid.filter_controls_changed |= 8;
					grid.s_controls["lines j"] = false;
				}

				if (grid.s_controls["lines k"])
				{
					grid.filter_controls_changed |= 16;
					grid.s_controls["lines k"] = false;
				}

				if (grid.s_controls["Default Style"])
				{
					grid.filter_controls_changed |= 2;
					grid.s_controls["Default Style"] = false;
					grid.style_default = false;

					grid.add_style_folders();
				}

				if (grid.fs_controls["faces ij"] || 
					grid.fs_controls["faces ik"] || 
					grid.fs_controls["faces ik"])
				{
					grid.fs_controls["faces ij"] = false;
					grid.fs_controls["faces ik"] = false;
					grid.fs_controls["faces jk"] = false;

					grid.state_f_directions = 
							(grid.state_f_directions != 0)? 0: 1;
				}

				if (grid.fs_controls["Default Style"])
				{
					grid.fs_controls["Default Style"] = false;
					grid.style_filter_default = false;

					grid.add_fstyle_folders();
				}

				for ( var i = 0; i < grid['$items'].length; i++ )
					grid['$items'][i].option_detail = [1, 1, 1];

				for ( k in grid.d_controls )
					grid.d_controls[k] = 'di = 1, dj = 1, dk = 1';
							
				grid.state_l_directions = 
					(grid.state_l_directions != 0)? 0: 1;

				grid.filter_scalar = value;

				while(grid.items_filter.length > 0)
				{
					var c = grid.items_filter.pop();
					grid.f_filter.remove(c);
				}

				grid.f_filter.removeFolder("Lines Style");
				grid.f_filter.removeFolder("Faces Style");

				var a = loader.min[value + 2]; 
				var b = loader.max[value + 2];

				var a_name = "min";
				var b_name = "max";

				grid.controls[a_name] = grid.filter_scalar_range[0];
				grid.controls[b_name] = grid.filter_scalar_range[1];

				var step = (!!loader.types[value - 1])? 1: 0.0001;
				
				var c;

				c = grid.f_filter.add(grid.controls, a_name, a, b).step(step);

				c.onFinishChange(function(value)
				{
					grid.filter_scalar_range = [
						value, grid.filter_scalar_range[1]];
				});

				grid.items_filter.push(c);

				c = grid.f_filter.add(grid.controls, b_name, a, b).step(step);

				c.onFinishChange(function(value)
				{
					grid.filter_scalar_range = [
						grid.filter_scalar_range[0], value];
				});

				grid.items_filter.push(c);

				c = grid.f_filter.add(grid.fs_controls, "Default Style");

				if ( !grid.style_filter_default ) grid.add_fstyle_folders();

				c.onFinishChange(function(value)
				{ 
					if ( value ) 
					{
						grid.f_filter.removeFolder("Lines Style");
						grid.f_filter.removeFolder("Faces Style");
					}
					else
					{
						grid.add_fstyle_folders();
						grid.state_l_directions = 
							(grid.state_l_directions != 0)? 0: 1;
						grid.state_f_directions = 
							(grid.state_f_directions != 0)? 0: 1;
					}

					grid.style_filter_default = value;
				});

				grid.items_filter.push(c);
			}

			function add_controls()
			{
				if (data_counter == 0 && grid.id_controls.length > 0) {

					while(grid.id_controls.length > 0)
					{
						var c = grid.id_controls.pop();
						c[0].remove(c[1]);
					}

					while(grid.items_filter.length > 0)
					{
						var c = grid.items_filter.pop();
						grid.f_filter.remove(c);
					}

					grid.f_filter.removeFolder("Lines Style");
					grid.f_filter.removeFolder("Faces Style");

					data_controls = {};

					block.option_visible = true;
				}

				var name = "#" + (block.z + 1).toString() + " visible";

				grid.controls[ name ] = true;

				data_controls[block.z] = [[name, 
					function(value){ 
						block.option_visible = value;
					}]];

				var d = [
					loader.grid[ block.z ].length, 
					loader.grid[ block.z ][0].length, 
					loader.grid[ block.z ][0][0].length]

				name = '#' + (block.z + 1).toString() + " (" + 
					d[2].toString() + ", " + 
					d[1].toString() + ", " +
					d[0].toString() + ")";

				for (var i = 0; i < 3; i++) 
					d[i] = Math.floor(d[i] / 25) + 1;

				grid.d_controls[ name ] = "di = " +
					d[2].toString() + ", dj = " + 
					d[1].toString() + ", dk = " +
					d[0].toString();

				block.option_detail = d;

				data_controls[block.z][1] = [name, 
					function(value){ 
						var numb = value.match(/\d+/g);
						
						if(!!numb && numb.length >= 3) {
							block.option_detail = [ 
								parseInt(numb[2]), 
								parseInt(numb[1]), 
								parseInt(numb[0]) ];
						} else {
							block.option_detail = [1, 1, 1];
							value =	'di = 1, dj = 1, dk = 1';
						}
					}];
				
				if (data_counter == loader.grid.length - 1) {

					var keys = Object.keys(data_controls);

					for (var i = 0; i < keys.length; i++)
					{
						var item, c;
						
						item = data_controls[i][0];
						c = grid.f_visible.add(grid.controls, item[0]);
						c.onFinishChange(item[1]);
						grid.id_controls.push([grid.f_visible, c]);

						item = data_controls[i][1];
						c = grid.f_detail.add(grid.d_controls, item[0]).listen();
						c.onFinishChange(item[1]);
						grid.id_controls.push([grid.f_detail, c]);
					}

					data_controls = {};
					
					grid.controls["all points"] = function() {
						for ( var i = 0; i < grid['$items'].length; i++ )
							grid['$items'][i].option_detail = [1, 1, 1];

						for ( k in grid.d_controls )
							grid.d_controls[k] = 'di = 1, dj = 1, dk = 1';
					};

					var c = grid.f_detail.add(grid.controls, "all points");

					grid.id_controls.push([grid.f_detail, c]);

					// points

					grid.point = [];
					grid.points_variable = "";

					if (loader.grid[0][0][0][0].length > 3) {

						grid.controls["variable"] = "";

						var lst = [""];

						for ( var i = 1; i <= loader.grid[0][0][0][0].length - 3; i++ ) 
							lst.push(i.toString());

						var c = grid.f_points.add(grid.controls, "variable", lst).listen();

						grid.id_controls.push([grid.f_points, c]);

						c.onFinishChange(function(value)
						{
							grid.points_variable = value;
						});

						grid.controls["point size"] = 0.25;

						var c = grid.f_points.add(grid.controls, "point size", 0, 0.5).step(0.05)
						
						grid.id_controls.push([grid.f_points, c]);

						c.onFinishChange(function(value)
						{
							grid.points_size = value;
							if ( grid.points_variable == "" && value != 0 && 
								loader.grid[0][0][0][0].length > 3)
							{
								grid.controls["variable"] = "1";
								grid.points_variable = "1";
							}
						});

						grid.controls["internal"] = false;

						var c = grid.f_points.add(grid.controls, "internal").listen();

						grid.id_controls.push([grid.f_points, c]);

						c.onFinishChange(function(value)
						{
							grid.points_options = [value];
						});	
					}

					// filter

					grid.filter_block = -1
					grid.filter_controls_changed = 0

					grid.s_controls["internal"] = true;
					
					grid.s_controls["Default Style"] = true;
					grid.style_default = true;

					grid.controls["parameter"] = "";

					var lst = [""];

					for ( var i = 1; i <= loader.grid.length; i++ ) 
						lst.push("Block " + i.toString());

					for ( var i = 1; i <= loader.types.length; i++ ) 
						lst.push("Scalar " + i.toString());

					var c = grid.f_filter.add(grid.controls, "parameter", lst).listen();

					grid.id_controls.push([grid.f_filter, c]);

					c.onFinishChange(function(value)
					{
						grid.filter_scalar = -1;

						var v = value.split(' ');

						if (value != "" && v[0] == "Block")
						{	
							value = v[1];

							var l;

							l = loader.grid[value - 1][0][0].length;
							grid.filter_detail_i = [0, l - 1, 1];
							l = loader.grid[value - 1][0].length;
							grid.filter_detail_j = [0, l - 1, 1];
							l = loader.grid[value - 1].length;
							grid.filter_detail_k = [l - 2, l - 1, 1];

							if ((4 & grid.filter_controls_changed) == 4)
								grid.s_controls["lines i"] = true;

							if ((8 & grid.filter_controls_changed) == 8)
								grid.s_controls["lines j"] = true;

							if ((16 & grid.filter_controls_changed) == 16)
								grid.s_controls["lines k"] = true;

							filter_upd(value);								
						} 
						else 
						{
							grid.filter_block = -1;

							while(grid.items_filter.length > 0)
							{
								var c = grid.items_filter.pop();
								grid.f_filter.remove(c);
							}

							grid.f_filter.removeFolder("Lines Style");
							grid.f_filter.removeFolder("Faces Style");

							if(grid.filter_controls_changed != 0)
							{
								if ((1 & grid.filter_controls_changed) == 1)
									grid.s_controls["internal"] = true;
								
								if ((2 & grid.filter_controls_changed) == 2)
								{
									grid.s_controls["Default Style"] = true;
									grid.style_default = true;

									grid.f_blocks.removeFolder("Lines Style");
									grid.f_blocks.removeFolder("Faces Style");
								}

								if ((4 & grid.filter_controls_changed) == 4)
									grid.s_controls["lines i"] = true;

								if ((8 & grid.filter_controls_changed) == 8)
									grid.s_controls["lines j"] = true;

								if ((16 & grid.filter_controls_changed) == 16)
									grid.s_controls["lines k"] = true;

								grid.filter_controls_changed = 0;
								
								grid.state_l_directions = 
									(grid.state_l_directions != 0)? 0: 1;
							}

							if (v[0] == "Scalar") 
							{
								value = parseInt(v[1]);

								var m = (loader.min[value + 2] + loader.max[value + 2]) / 2;
								
								if (!!loader.types[value - 1]) 
									m = Math.ceil(m);

								grid.filter_scalar_range = [
									Math.min(loader.max[value + 2], m),
									loader.max[value + 2]];

								filter_scalar_upd(value);
							}
						} 
					});

					function keypress_event(e) 
					{
						var ch = String.fromCharCode(e.keyCode);

						if (ch != 'k' && ch != 'K' && ch != 'j' && ch != 'J' &&
							ch != 'i' && ch != 'I' && ch != 'b' && ch != 'B' &&
							ch != 'л' && ch != 'Л' && ch != 'о' && ch != 'О' &&
							ch != 'ш' && ch != 'Ш' && ch != 'и' && ch != 'И')
							return;

						if (grid.filter_block < 0)
						{
							grid.controls["parameter"] = "Block 1";

							grid.filter_detail_i = [0, 1, 1];
							grid.filter_detail_j = [0, 1, 1];
							grid.filter_detail_k = [0, 1, 1];
							grid.filter_block = 0;

							filter_upd("1");
						}
						else 
						{
							var b = grid.filter_block;

							var k = grid.filter_detail_k[0];
							var j = grid.filter_detail_j[0];
							var i = grid.filter_detail_i[0];

							switch(ch)
							{
								case 'k':
								case 'л': 
									if ( k < loader.grid[b].length - 2 ) k++; 
									else k = loader.grid[b].length - 2; 
									break;
								case 'K':
								case 'Л':
									if (k > 1) k--; else k = 1; 
									break;
								case 'j': 
								case 'о': 
									if ( j < loader.grid[b][0].length - 2 ) j++; 
									else j = loader.grid[b][0].length - 2; 
									break;
								case 'J':
								case 'О': 
									if (j > 1) j--; else j = 1; 
									break;
								case 'i': 
								case 'ш': 
									if ( i < loader.grid[b][0][0].length - 2 ) i++;
									else i = loader.grid[b][0][0].length - 2;
									break;
								case 'I':
								case 'Ш': 
									if (i > 1) i--; else i = 1; 
									break;
								case 'b':
								case 'и':
									if( b < loader.grid.length - 1 ) b++; else b = 0;
									if (k > loader.grid[b].length - 2 ) 
										k = loader.grid[b].length - 2;
									if (j > loader.grid[b][0].length - 2 ) 
										j = loader.grid[b][0].length - 2;
									if (i > loader.grid[b][0][0].length - 2 ) 
										i = loader.grid[b][0][0].length - 2;
									break;
								case 'B':
								case 'И':
									if(b > 1) b--; else b = loader.grid.length - 1;
									if (k > loader.grid[b].length - 2 ) 
										k = loader.grid[b].length - 2;
									if (j > loader.grid[b][0].length - 2 ) 
										j = loader.grid[b][0].length - 2;
									if (i > loader.grid[b][0][0].length - 2 ) 
										i = loader.grid[b][0][0].length - 2;
									break;
							}

							grid.filter_detail_k = [k, k + 1, 1];
							grid.filter_detail_j = [j, j + 1, 1];
							grid.filter_detail_i = [i, i + 1, 1];

							grid.filter_block = b;

							grid.controls["parameter"] = "Block " + (b + 1).toString();

							filter_upd((b + 1).toString());
						}
					}
					
					window.addEventListener( "keypress", keypress_event, false );
				}

				data_counter ++;
			}

			GridLines
			{
				visible: block.option_visible

				data: loader.grid[ block.z ]
				scale_coeff: loader.scale_coeff

				detail: block.option_detail

				filter: block.z != grid.filter_block ? []: 
					[ grid.filter_detail_k,
					  grid.filter_detail_j, 
					  grid.filter_detail_i ]

				directions: grid.style_default ? [] : grid.l_directions
				colors: grid.style_default ? [] : grid.l_colors
				options: grid.style_default ? [] : grid.l_options

				filter_directions: grid.style_filter_default ? [] : 
					grid.l_filter_directions
				filter_colors: grid.style_filter_default ? [] : 
					grid.l_filter_colors
				filter_options: grid.style_filter_default ? [] : 
					grid.l_filter_options

				filter_scalar: (grid.filter_scalar != -1)? 
					[grid.filter_scalar, grid.filter_scalar_range]: []
			}

			GridFaces
			{
				visible: block.option_visible

				data: loader.grid[ block.z ]
				scale_coeff: loader.scale_coeff

				detail: block.option_detail

				filter: block.z != grid.filter_block ? []: 
					[ grid.filter_detail_k,
					  grid.filter_detail_j, 
					  grid.filter_detail_i ]

				directions: grid.style_default ? [] : grid.f_directions
				colors: grid.f_colors
				options:  grid.f_options

				filter_directions: grid.style_filter_default ? [] : 
					grid.f_filter_directions
				filter_colors: grid.f_filter_colors
				filter_options: grid.f_filter_options

				filter_scalar: (grid.filter_scalar != -1)? 
					[grid.filter_scalar, grid.filter_scalar_range]: []
			}

			GridPoints
			{
				id: gridpoints
				visible: block.option_visible
				data: loader.grid[ block.z ]
				scale_coeff: loader.scale_coeff
				variable: grid.points_variable
				min: loader.min
				max: loader.max
				index: block.z
				colors: legend.colors
				radius: grid.points_size
				options: grid.points_options
				types: loader.types
			}
		}
	}

	SceneMouseEvents {
		
		onDoubleClicked: {			
			
			var min;
			var min_r;
			var min_ind;

			for (var i = 0; i < grid['$items'].length ; i++) {
				
				var gridpoints = grid['$items'][i]['$tidyupList'][3];

				var r = gridpoints.intersect( sceneMouse );

				if (!!r && grid['$items'][i].option_visible)
				{
					if (!min || r.distance < min)
					{
						min = r.distance;
						min_r = r;
						min_ind = gridpoints.index;
					}
				}
			};

			if (!!min_r)
			{
				var nk, nj, ni, k, j, i;

				ni = loader.grid[ min_ind ][0][0].length;
				nj = loader.grid[ min_ind ][0].length;
				nk = loader.grid[ min_ind ].length;

				if (grid.points_options[0])
				{
					k = Math.floor(min_r.index / (ni * nj));
					j = Math.floor((min_r.index - k * ni * nj) / ni);
					i = min_r.index - k * ni * nj - j * ni;
				} else {
					var ind = -1;
					var f = false;

					for (var kt = 0; kt < nk; kt++)
					{	
						for (var jt = 0; jt < nj; jt++)
						{
							for (var it = 0; it < ni; it++)
							{
								if (kt == 0 || kt == nk - 1 ||
									jt == 0 || jt == nj - 1 ||
									it == 0 || it == ni - 1) 
									ind ++;

								if (ind == min_r.index)
								{
									k = kt; j = jt; i = it; 
									f = true;
								}

								if (f) break;
							}
							if (f) break;
						}
						if (f) break;
					}
				}

				tmp = loader.grid[ min_ind ][k][j][i];

				if (grid.point[0] != tmp[0] || grid.point[1] != tmp[1] || 
					grid.point[2] != tmp[2])
				{
					grid.point_size = grid.points_size * 2;
					grid.point = tmp;
					grid.point_ind = [min_ind, k, j, i];
				}
				else
				{
					grid.point_size = (grid.point_size == grid.points_size)?
						grid.points_size * 2: grid.points_size
				}
			}
		}
	}

	GridPoints
	{
		visible: (!!grid.point && grid.point.length > 3)
		data: (!!grid.point && grid.point.length > 3)? [[[ grid.point.slice() ]]]: []
		scale_coeff: loader.scale_coeff
		variable: grid.points_variable
		min: loader.min
		max: loader.max
		colors: legend.colors
		radius: grid.point_size
		types: loader.types
	}

	Column
	{
		property var tag: "left"

		Text
		{
			text: (grid.points_variable != "" && 
					parseInt(grid.points_variable) + 3 <= loader.grid[0][0][0][0].length && 
					!!grid.point && grid.point.length > 3 &&
					grid.point_size != grid.points_size)? msg(): ""
			
			function msg()
			{
				var m = '<span style="' + 
				'font-size: 120%; color: white; background-color: rgba(0, 0, 0, 0.7);">' + 
				"&nbsp;Selected: ";

				m += "block: " + (grid.point_ind[0] + 1).toString() + ";&nbsp;\n"; 

				if(grid.point_ind.length > 2)
				{
					m += "&nbsp;i: " + (grid.point_ind[3] + 1).toString() + "; j: " +
						(grid.point_ind[2] + 1).toString() + "; k: " + 
						(grid.point_ind[1] + 1).toString() + ";&nbsp;\n\n";
				}

				if(grid.point.length > 2)
				{
					m += "&nbsp;x = " + grid.point[0] + ";&nbsp;\n&nbsp;y = " +
						 grid.point[1] + ";&nbsp;\n&nbsp;z = " + grid.point[2] + ";&nbsp;\n\n";
				}

				for(var i = 3; i < grid.point.length; i++)
				{
					m += (parseInt(grid.points_variable) + 2 != i)? 
						"&nbsp;" + grid.point[i] + ";&nbsp;\n": 
						"&nbsp;[&nbsp;" + grid.point[i] + "&nbsp;];&nbsp;\n";
				}

				return m + "</span>" + "\n";
			}
		}

		Text
		{
			text: (grid.points_variable != "" && 
					parseInt(grid.points_variable) + 3 <= loader.grid[0][0][0][0].length )? 
					"Points:": ""
		}

		Column
		{

			Row
			{
				Item
				{
					id: legend

					height: 18
					width: 180

					property var htmlNode
					property var colors: get_colors(loader.types, grid.points_variable);

					function get_colors(types, variable)
					{
						if (types.length > 0 && variable!= "" && 
							!!types[parseInt(variable) - 1]) 
						{
							var values = Object.keys(types[parseInt(variable) - 1]);

							var coeff = Math.floor(values.length / 3);
							var offset = coeff - 1 - (values.length % coeff);	

							var step = 1 / (values.length + offset);

							var cols = [];
							var color = 0;

							if (values.length < 3) { step = 1 / 6; coeff = 1; offset = 0; }

							for (var i = 0; i < values.length; i++)
							{
								color = ((i * coeff) % (values.length + offset)) * step;

								if (color > 0.3 && color < 0.45){

									var cf = (i * coeff) % (values.length + offset);

									var v = ((cf % 2)? -1: 1) * 
										(cf / (values.length + offset)) * 0.3;
									
									cols.push("#" + new THREE.Color()
										.setHSL(color, 0.96 - color + v, 0.56 - v).getHex().toString(16));
								}
								else if (color > 0.65 && color < 0.7) {
									cols.push("#" + new THREE.Color()
										.setHSL(color, 0.96 - color / 3, 0.56).getHex().toString(16));
								}
								else
									cols.push("#" + new THREE.Color()
										.setHSL(color, 0.96, 0.56).getHex().toString(16));
							}

							return cols;
						}

						return ["#0022ff", "#00ddff", "#66ff33", "#ffff00", "#ffbb00", "#ff2200"];
					}
					
					property var scalar: (grid.points_variable == "" || 
						parseInt(grid.points_variable) + 3 <= loader.grid[0][0][0][0].length)? 
							grid.points_variable : ""

					property var range: (grid.points_variable != "" && 
						parseInt(grid.points_variable) + 3 <= loader.grid[0][0][0][0].length)? 
						[loader.min[parseInt(grid.points_variable) + 2], 
						loader.max[parseInt(grid.points_variable) + 2]]: 
						[0, 1]

					Component.onCompleted: {

						legend.dom.innerHTML = "<div>" + 
							"<canvas id='legend' style='position: relative'> </canvas>" + 
							"<svg style='position: relative'> </svg>" +
							"</div>";

						htmlNode = legend.dom.firstChild;
						htmlNode.style.display = "none";
					}

					function draw_gradient()
					{
						if(!!htmlNode)
						{
							var canvas = htmlNode.childNodes[0];

							width = 180;
							height = 18;

							canvas.width = width;
							canvas.height = height + 32;

							var svg = htmlNode.childNodes[1];
							svg.innerHTML = "";

							svg.setAttribute('style', 
								'width: ' + width + '; height:' + (height + 32).toString());

							htmlNode.style.display = (scalar == "")? "none": "block";

							var ctx = canvas.getContext("2d");

							ctx.rect(0, 0, canvas.width, canvas.height);
							ctx.clearRect(0, 0, canvas.width, canvas.height);

							if (scalar != "" && loader.types.length > 0 && 
							!!loader.types[parseInt(scalar) - 1])
							{
								// canvas

								width = 100;
								height = 32 * colors.length;

								canvas.width = width;
								canvas.height = height;

								ctx.fillStyle = "#FFFFFF";
								ctx.fillRect(0, 0, width, height);

								keys = Object.keys(loader.types[scalar - 1]);

								for(var i = 0; i < colors.length; i++)
								{
									ctx.fillStyle = colors[i];
									ctx.fillRect(3, 32 * i + 5, 23, 20);

									ctx.fillStyle = "#000000";
									ctx.font = "14pt Arial";

									ctx.textAlign = "left";
									ctx.fillText(keys[i].toString(), 33, 32 * i + 22);
								}

								// svg

								svg.setAttribute('style', 
									'width: ' + width + '; height:' + height);

								var svgns = "http://www.w3.org/2000/svg";

								for(var i = 0; i < colors.length; i++)
								{
									var rect = document.createElementNS(svgns, 'rect');
									rect.setAttributeNS(null, 'x', 3);
									rect.setAttributeNS(null, 'y', 32 * i + 5);
									rect.setAttributeNS(null, 'width', 23);
									rect.setAttributeNS(null, 'height', 20);
									rect.setAttributeNS(null, 'fill', colors[i]);

									svg.appendChild(rect);

									var text = document.createElementNS(svgns, 'text');
								
									text.setAttributeNS(null, 'x', 33);
									text.setAttributeNS(null, 'y', 32 * i + 22);
									text.setAttributeNS(null, 'fill', '#000000');
									text.setAttributeNS(null, 'text-anchor', 'start');
									text.appendChild(document.createTextNode(
										keys[i].toString()));

									svg.appendChild(text);
								}

							}
							else if (scalar != "") 
							{
								// canvas

								ctx.fillStyle = "#FFFFFF";
								ctx.fillRect(0, 0, canvas.width, canvas.height);

								var gradient = ctx.createLinearGradient(0, 0, width, 0);

								for(var i = 0; i < colors.length; i++)
									gradient.addColorStop(i / (colors.length - 1), colors[i]);

								ctx.fillStyle = gradient;
								ctx.fillRect(3, 3, width - 6, height + 2);

								ctx.fillStyle = "#000000";
								ctx.font = "14pt Arial";

								ctx.textAlign = "left";
								ctx.fillText(range[0].toFixed(5).toString(), 
									0, height + 22);
								ctx.textAlign = "right";
								ctx.fillText(range[1].toFixed(5).toString(), 
									width, height + 22);

								// svg

								var svgns = "http://www.w3.org/2000/svg";

								var rect = document.createElementNS(svgns, 'rect');
								rect.setAttributeNS(null, 'x', 3);
								rect.setAttributeNS(null, 'y', 3);
								rect.setAttributeNS(null, 'width', width - 6);
								rect.setAttributeNS(null, 'height', height + 2);
								
								var grad = document.createElementNS(svgns, 'linearGradient');
								grad.setAttributeNS(null, 'id', 'grad');

								for(var i = 0; i < colors.length; i++)
								{
									var stop = document.createElementNS(svgns, 'stop');
									stop.setAttributeNS(null, 'offset', i / (colors.length - 1));
									stop.setAttributeNS(null, 'stop-color', colors[i]);
									grad.appendChild(stop);
								}

								var defs = document.createElementNS(svgns, 'defs')
								defs.appendChild(grad);

								svg.insertBefore(defs, svg.firstChild);
								rect.setAttributeNS(null, 'fill', 'url(#grad)');
								svg.appendChild(rect);

								var text;

								text = document.createElementNS(svgns, 'text');
								
								text.setAttributeNS(null, 'x', 0);
								text.setAttributeNS(null, 'y', height + 22);
								text.setAttributeNS(null, 'fill', '#000000');
								text.setAttributeNS(null, 'text-anchor', 'start');
								text.appendChild(document.createTextNode(
									range[0].toFixed(5).toString()));

								svg.appendChild(text);

								text = document.createElementNS(svgns, 'text');
								
								text.setAttributeNS(null, 'x', width);
								text.setAttributeNS(null, 'y', height + 22);
								text.setAttributeNS(null, 'fill', '#000000');
								text.setAttributeNS(null, 'text-anchor', 'end');
								text.appendChild(document.createTextNode(
									range[1].toFixed(5).toString()));

								svg.appendChild(text);
							}

							svg.style.display = "none";
						}
					}

					onRangeChanged: draw_gradient();
					onScalarChanged: draw_gradient();
				}
			}
		}
	}	
}
